#!/bin/zsh
# todo - AI-Agent First TODO List Tracker
# 
# Copyright 2025 Oliver Ratzesberger
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# AI-agent first TODO list management tool
# Keep AI agents on track and help humans supervise their work
#
# Version: 1.6.4
# Repository: https://github.com/fxstein/todo.ai
# Update: ./todo.ai update

set -e
set +x  # Explicitly disable debug/trace output

# Cross-platform sed in-place editing function
sed_inplace() {
    if [[ "$(uname)" == "Darwin" ]]; then
        sed -i '' "$@"
    else
        sed -i "$@"
    fi
}

# Version
VERSION="1.6.4"
REPO_URL="https://github.com/fxstein/todo.ai"
SCRIPT_URL="https://raw.githubusercontent.com/fxstein/todo.ai/main/todo.ai"

# Configuration
# Can be overridden with environment variables
TODO_FILE="${TODO_FILE:-$(pwd)/TODO.md}"
SERIAL_FILE="${TODO_SERIAL:-$(pwd)/.todo.ai/.todo.ai.serial}"
LOG_FILE="${TODO_LOG:-$(pwd)/.todo.ai/.todo.ai.log}"
CONFIG_FILE="${TODO_CONFIG:-$(pwd)/.todo.ai/config.yaml}"

# ============================================================================
# Hybrid Task Numbering System
# ============================================================================

# Configuration file path
get_config_file() {
    echo "$CONFIG_FILE"
}

# Read YAML config value (supports nested keys like coordination.type)
get_config_value() {
    local key="$1"  # e.g., "mode" or "coordination.type"
    local config_file=$(get_config_file)
    local default="${2:-}"
    
    if [[ ! -f "$config_file" ]]; then
        echo "$default"
        return 0
    fi
    
    # Try yq first (best YAML parser)
    if command -v yq >/dev/null 2>&1; then
        local value=$(yq eval ".$key" "$config_file" 2>/dev/null || echo "")
        if [[ -n "$value" ]] && [[ "$value" != "null" ]]; then
            echo "$value"
            return 0
        fi
    fi
    
    # Fallback to Python if available
    if command -v python3 >/dev/null 2>&1; then
        local value=$(python3 <<EOF
import yaml
import sys
try:
    with open('$config_file', 'r') as f:
        config = yaml.safe_load(f)
        if config is None:
            print('')
            sys.exit(0)
        # Handle nested keys (e.g., "coordination.type")
        keys = '$key'.split('.')
        value = config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                print('')
                sys.exit(0)
        print(str(value) if value is not None else '')
except Exception as e:
    print('')
    sys.exit(1)
EOF
)
        if [[ -n "$value" ]]; then
            echo "$value"
            return 0
        fi
    fi
    
    # Fallback to simple grep/sed for mode (top-level only)
    if [[ "$key" == "mode" ]]; then
        local value=$(grep "^mode:" "$config_file" 2>/dev/null | sed 's/^mode:[[:space:]]*//' | sed 's/[[:space:]]*$//' || echo "")
        if [[ -n "$value" ]]; then
            echo "$value"
            return 0
        fi
    fi
    
    echo "$default"
}

# Get numbering mode (default: single-user)
get_numbering_mode() {
    get_config_value "mode" "single-user"
}

# Validate configuration
validate_config() {
    local config_file=$(get_config_file)
    
    if [[ ! -f "$config_file" ]]; then
        # No config file is valid (defaults to single-user)
        return 0
    fi
    
    local mode=$(get_numbering_mode)
    
    # Check mode is valid
    case "$mode" in
        "single-user"|"multi-user"|"branch"|"enhanced")
            ;;
        *)
            echo "ERROR: Invalid mode in config: $mode" >&2
            echo "Valid modes: single-user, multi-user, branch, enhanced" >&2
            return 1
            ;;
    esac
    
    # Validate coordination settings if enhanced mode
    if [[ "$mode" == "enhanced" ]]; then
        local coord_type=$(get_config_value "coordination.type" "")
        case "$coord_type" in
            "github-issues")
                local issue_num=$(get_config_value "coordination.issue_number" "")
                if [[ -z "$issue_num" ]] || ! [[ "$issue_num" =~ ^[0-9]+$ ]]; then
                    echo "ERROR: Invalid or missing coordination.issue_number for github-issues mode" >&2
                    return 1
                fi
                ;;
            "counterapi")
                local namespace=$(get_config_value "coordination.namespace" "")
                if [[ -z "$namespace" ]]; then
                    echo "ERROR: Missing coordination.namespace for counterapi mode" >&2
                    return 1
                fi
                ;;
            "none"|"")
                # No coordination is valid (will use fallback)
                ;;
            *)
                echo "ERROR: Invalid coordination.type: $coord_type" >&2
                echo "Valid types: github-issues, counterapi, none" >&2
                return 1
                ;;
        esac
    fi
    
    return 0
}

# Create backup before mode switching
create_mode_backup() {
    local backup_dir="$(pwd)/.todo.ai/backups"
    local timestamp=$(date +"%Y%m%d%H%M%S")
    local backup_name="mode-switch-${timestamp}"
    
    # Ensure backup directory exists
    mkdir -p "$backup_dir" 2>/dev/null || return 1
    
    # Create backup of TODO.md and config.yaml
    local backup_todo="${backup_dir}/${backup_name}.TODO.md"
    local backup_config="${backup_dir}/${backup_name}.config.yaml"
    local backup_serial="${backup_dir}/${backup_name}.serial"
    
    # Copy files
    if [[ -f "$TODO_FILE" ]]; then
        cp "$TODO_FILE" "$backup_todo" 2>/dev/null || return 1
    fi
    
    local config_file=$(get_config_file)
    if [[ -f "$config_file" ]]; then
        cp "$config_file" "$backup_config" 2>/dev/null || return 1
    fi
    
    if [[ -f "$SERIAL_FILE" ]]; then
        cp "$SERIAL_FILE" "$backup_serial" 2>/dev/null || return 1
    fi
    
    echo "$backup_name"
    return 0
}

# Rollback from backup
rollback_from_backup() {
    local backup_name="$1"
    
    if [[ -z "$backup_name" ]]; then
        echo "Error: Please provide backup name"
        echo "Usage: ./todo.ai rollback-mode <backup-name>"
        echo "List backups: ./todo.ai list-mode-backups"
        return 1
    fi
    
    local backup_dir="$(pwd)/.todo.ai/backups"
    local backup_todo="${backup_dir}/${backup_name}.TODO.md"
    local backup_config="${backup_dir}/${backup_name}.config.yaml"
    local backup_serial="${backup_dir}/${backup_name}.serial"
    
    # Check if backup exists
    if [[ ! -f "$backup_todo" ]]; then
        echo "Error: Backup '$backup_name' not found"
        return 1
    fi
    
    # Restore files
    if [[ -f "$backup_todo" ]]; then
        cp "$backup_todo" "$TODO_FILE" 2>/dev/null || {
            echo "Error: Could not restore TODO.md"
            return 1
        }
    fi
    
    local config_file=$(get_config_file)
    if [[ -f "$backup_config" ]]; then
        cp "$backup_config" "$config_file" 2>/dev/null || {
            echo "Error: Could not restore config.yaml"
            return 1
        }
    elif [[ -f "$config_file" ]]; then
        # If backup has no config but current has one, remove it
        rm -f "$config_file" 2>/dev/null || true
    fi
    
    if [[ -f "$backup_serial" ]]; then
        cp "$backup_serial" "$SERIAL_FILE" 2>/dev/null || {
            echo "Error: Could not restore serial file"
            return 1
        }
    fi
    
    echo "âœ… Rollback complete: restored from backup '$backup_name'"
    return 0
}

# List mode backups
list_mode_backups() {
    local backup_dir="$(pwd)/.todo.ai/backups"
    
    if [[ ! -d "$backup_dir" ]]; then
        echo "No backups found"
        return 0
    fi
    
    local backups=()
    for backup_file in "$backup_dir"/mode-switch-*.TODO.md; do
        if [[ -f "$backup_file" ]]; then
            local backup_name=$(basename "$backup_file" | sed 's/\.TODO\.md$//')
            backups+=("$backup_name")
        fi
    done
    
    if [[ ${#backups[@]} -eq 0 ]]; then
        echo "No mode switch backups found"
        return 0
    fi
    
    echo "Mode switch backups:"
    echo ""
    for backup in "${backups[@]}"; do
        local timestamp=$(echo "$backup" | sed 's/mode-switch-//')
        local date_str=$(echo "$timestamp" | sed 's/\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\1-\2-\3 \4:\5:\6/')
        echo "  $backup ($date_str)"
    done
}

# Get GitHub user ID (first 7 characters)
get_github_user_id() {
    local user_id=""
    
    # Try GitHub CLI first
    if command -v gh >/dev/null 2>&1; then
        user_id=$(gh api user --jq '.login' 2>/dev/null || echo "")
    fi
    
    # Fallback to Git config
    if [[ -z "$user_id" ]]; then
        # Try git config user.name
        local git_user=$(git config --get user.name 2>/dev/null || echo "")
        if [[ -n "$git_user" ]]; then
            # Convert to lowercase, remove non-alphanumeric, take first 7 chars
            user_id=$(echo "$git_user" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]' | cut -c1-7)
        fi
    fi
    
    # Final fallback
    if [[ -z "$user_id" ]]; then
        # Use system username as last resort
        local sys_user=$(whoami 2>/dev/null || echo "user")
        user_id=$(echo "$sys_user" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]' | cut -c1-7)
    fi
    
    # Ensure we have something (at least 1 char)
    if [[ -z "$user_id" ]]; then
        user_id="user"
    fi
    
    # Take first 7 characters
    echo "${user_id:0:7}"
}

# Get current Git branch name (first 7 characters)
get_branch_name() {
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    
    if [[ -z "$branch" ]] || [[ "$branch" == "HEAD" ]]; then
        echo "main"  # Default branch name
        return 0
    fi
    
    # Take first 7 characters, remove non-alphanumeric
    branch=$(echo "$branch" | tr -cd '[:alnum:]_' | cut -c1-7)
    
    # Ensure we have something
    if [[ -z "$branch" ]]; then
        branch="main"
    fi
    
    echo "$branch"
}

# Assign task number based on current mode
assign_task_number() {
    local mode=$(get_numbering_mode)
    
    case "$mode" in
        "single-user")
            # Mode 1: Simple sequential numbering
            increment_serial
            ;;
        "multi-user")
            # Mode 2: Prefix with GitHub user ID
            assign_task_number_multi_user
            ;;
        "branch")
            # Mode 3: Prefix with branch name
            assign_task_number_branch
            ;;
        "enhanced")
            # Mode 4: Enhanced coordination (GitHub Issues or CounterAPI)
            assign_task_number_enhanced
            ;;
        *)
            # Fallback to single-user
            increment_serial
            ;;
    esac
}

# Mode 2: Multi-user numbering (user-prefix)
assign_task_number_multi_user() {
    local user_prefix=$(get_github_user_id)
    local todo_file="$TODO_FILE"
    
    # Find highest task number for this user prefix
    local highest=0
    
    # Construct pattern variable for zsh regex compatibility
    local pattern="\\*\\*#${user_prefix}-([0-9]+)\\*\\*"
    
    while IFS= read -r line; do
        # Match task IDs like fxstein-50 in TODO.md
        # Use pattern variable for zsh compatibility
        if [[ "$line" =~ $pattern ]]; then
            local num="${match[1]}"
            if [[ $num -gt $highest ]]; then
                highest=$num
            fi
        fi
    done < "$todo_file"
    
    local next_num=$((highest + 1))
    echo "${user_prefix}-${next_num}"
}

# Mode 3: Branch numbering (branch-prefix)
assign_task_number_branch() {
    local branch_prefix=$(get_branch_name)
    local todo_file="$TODO_FILE"
    
    # Find highest task number for this branch prefix
    local highest=0
    
    # Construct pattern variable for zsh regex compatibility
    local pattern="\\*\\*#${branch_prefix}-([0-9]+)\\*\\*"
    
    while IFS= read -r line; do
        # Match task IDs like feature-50 in TODO.md
        # Use pattern variable for zsh compatibility
        if [[ "$line" =~ $pattern ]]; then
            local num="${match[1]}"
            if [[ $num -gt $highest ]]; then
                highest=$num
            fi
        fi
    done < "$todo_file"
    
    local next_num=$((highest + 1))
    echo "${branch_prefix}-${next_num}"
}

# Mode 4: Enhanced multi-user numbering (with coordination)
assign_task_number_enhanced() {
    local coord_type=$(get_config_value "coordination.type" "none")
    local fallback_mode=$(get_config_value "coordination.fallback" "multi-user")
    
    case "$coord_type" in
        "github-issues")
            assign_task_number_enhanced_github_issues || assign_task_number_enhanced_fallback "$fallback_mode"
            ;;
        "counterapi")
            assign_task_number_enhanced_counterapi || assign_task_number_enhanced_fallback "$fallback_mode"
            ;;
        *)
            # No coordination configured, use fallback
            assign_task_number_enhanced_fallback "$fallback_mode"
            ;;
    esac
}

# Enhanced mode: GitHub Issues coordination
assign_task_number_enhanced_github_issues() {
    local issue_num=$(get_config_value "coordination.issue_number" "")
    local repo_url=$(git config --get remote.origin.url 2>/dev/null | sed 's/\.git$//' | sed 's/.*github\.com[:/]//' || echo "")
    
    if [[ -z "$issue_num" ]] || [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
        return 1  # Trigger fallback
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        return 1  # Trigger fallback
    fi
    
    # Get latest comment from issue
    local latest_comment=$(gh api repos/${repo_url}/issues/${issue_num}/comments --jq '.[0].body' 2>/dev/null || echo "")
    
    if [[ -z "$latest_comment" ]]; then
        # No comments yet, start with 1
        local new_num=1
    else
        # Extract number from comment (format: "Next task number: 123" or just "123")
        local current_num=$(echo "$latest_comment" | grep -oE '[0-9]+' | tail -1)
        if [[ -z "$current_num" ]]; then
            current_num=0
        fi
        local new_num=$((current_num + 1))
    fi
    
    # Append new number as comment (with retry on conflicts)
    local max_retries=3
    local retry=0
    while [[ $retry -lt $max_retries ]]; do
        # Create comment with new number
        if gh api -X POST repos/${repo_url}/issues/${issue_num}/comments --field "body=Next task number: $new_num" >/dev/null 2>&1; then
            # Get user prefix for formatting
            local user_prefix=$(get_github_user_id)
            echo "${user_prefix}-${new_num}"
            return 0
        fi
        
        # Check if number changed (concurrent update)
        local updated_comment=$(gh api repos/${repo_url}/issues/${issue_num}/comments --jq '.[0].body' 2>/dev/null || echo "")
        local updated_num=$(echo "$updated_comment" | grep -oE '[0-9]+' | tail -1)
        if [[ -n "$updated_num" ]] && [[ "$updated_num" != "$current_num" ]]; then
            # Number changed, retry with new number
            current_num=$updated_num
            new_num=$((current_num + 1))
            retry=$((retry + 1))
        else
            # Unknown error, fallback
            return 1
        fi
    done
    
    # Max retries reached, fallback
    return 1
}

# Enhanced mode: CounterAPI coordination
assign_task_number_enhanced_counterapi() {
    local namespace=$(get_config_value "coordination.namespace" "")
    local counter_name="task-counter"
    
    if [[ -z "$namespace" ]] || ! command -v curl >/dev/null 2>&1; then
        return 1  # Trigger fallback
    fi
    
    # Increment atomically via CounterAPI
    local response=$(curl -s -X POST "https://api.counterapi.dev/v1/${namespace}/${counter_name}/up" 2>/dev/null || echo "")
    
    if [[ -z "$response" ]]; then
        return 1  # Trigger fallback
    fi
    
    # Parse response (expect JSON with "value" field)
    local new_num=""
    if command -v jq >/dev/null 2>&1; then
        new_num=$(echo "$response" | jq -r '.value' 2>/dev/null || echo "")
    elif command -v python3 >/dev/null 2>&1; then
        new_num=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('value', ''))" 2>/dev/null || echo "")
    fi
    
    if [[ -z "$new_num" ]] || ! [[ "$new_num" =~ ^[0-9]+$ ]]; then
        return 1  # Trigger fallback
    fi
    
    # Get user prefix for formatting
    local user_prefix=$(get_github_user_id)
    echo "${user_prefix}-${new_num}"
    return 0
}

# Enhanced mode: Fallback to simpler mode
assign_task_number_enhanced_fallback() {
    local fallback_mode="$1"
    
    case "$fallback_mode" in
        "multi-user")
            assign_task_number_multi_user
            ;;
        "branch")
            assign_task_number_branch
            ;;
        *)
            # Default to single-user
            increment_serial
            ;;
    esac
}

# Resolve task reference (auto-add prefix for number-only references)
resolve_task_reference() {
    local input="$1"
    local mode=$(get_numbering_mode)
    
    # If already has prefix (format: prefix-number), use as-is
    if [[ "$input" =~ ^[a-z0-9]{1,7}-[0-9]+$ ]]; then
        echo "$input"
        return 0
    fi
    
    # If just a number, add prefix based on mode
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        case "$mode" in
            "multi-user"|"enhanced")
                local user_prefix=$(get_github_user_id)
                echo "${user_prefix}-${input}"
                return 0
                ;;
            "branch")
                local branch_prefix=$(get_branch_name)
                echo "${branch_prefix}-${input}"
                return 0
                ;;
            "single-user")
                # No prefix needed for single-user
                echo "$input"
                return 0
                ;;
        esac
    fi
    
    # Invalid format
    echo "ERROR: Invalid task ID format: $input" >&2
    return 1
}

# Extract numeric part from task ID (removes prefix if present)
extract_task_number() {
    local task_id="$1"
    
    # If has prefix (format: prefix-number), extract number
    if [[ "$task_id" =~ ^[a-z0-9]{1,7}-([0-9]+)$ ]]; then
        echo "${match[1]}"
        return 0
    fi
    
    # If has subtask format (prefix-number.subtask), extract both parts
    if [[ "$task_id" =~ ^[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)$ ]]; then
        echo "${match[1]}.${match[2]}"
        return 0
    fi
    
    # If just number or number.subtask, return as-is
    if [[ "$task_id" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        echo "$task_id"
        return 0
    fi
    
    # Invalid format
    return 1
}

# Generate new task ID based on mode and numeric part
generate_new_task_id() {
    local numeric_part="$1"
    local mode="$2"
    
    # Extract parent and subtask numbers if present
    local parent_num=""
    local subtask_num=""
    if [[ "$numeric_part" =~ ^([0-9]+)\.([0-9]+)$ ]]; then
        parent_num="${match[1]}"
        subtask_num="${match[2]}"
    elif [[ "$numeric_part" =~ ^([0-9]+)$ ]]; then
        parent_num="${match[1]}"
    else
        return 1
    fi
    
    # Generate prefix based on mode
    local prefix=""
    case "$mode" in
        "multi-user"|"enhanced")
            prefix=$(get_github_user_id)
            ;;
        "branch")
            prefix=$(get_branch_name)
            ;;
        "single-user")
            prefix=""  # No prefix
            ;;
        *)
            return 1
            ;;
    esac
    
    # Build new ID
    if [[ -z "$prefix" ]]; then
        # Single-user: no prefix
        if [[ -n "$subtask_num" ]]; then
            echo "${parent_num}.${subtask_num}"
        else
            echo "${parent_num}"
        fi
    else
        # Multi-user/branch: with prefix
        if [[ -n "$subtask_num" ]]; then
            echo "${prefix}-${parent_num}.${subtask_num}"
        else
            echo "${prefix}-${parent_num}"
        fi
    fi
}

# Renumber tasks when switching modes
renumber_tasks_for_mode() {
    local old_mode="$1"
    local new_mode="$2"
    
    if [[ ! -f "$TODO_FILE" ]]; then
        return 1
    fi
    
    # Build ID mapping: old_id -> new_id
    declare -A id_mapping
    
    # Collect all task IDs from TODO.md
    local temp_file=$(mktemp)
    local tasks_found=0
    
    # Find all task IDs in TODO.md (handle both prefixed and non-prefixed formats)
    while IFS= read -r line; do
        # Match task IDs in format: **#task_id** or **#prefix-task_id**
        # Handle both main tasks and subtasks
        if [[ "$line" =~ \*\*#([0-9a-z.\-]+)\*\* ]]; then
            local full_task_id="${match[1]}"
            
            # Extract numeric part (removes prefix if present)
            local numeric_part=$(extract_task_number "$full_task_id" 2>/dev/null)
            if [[ -z "$numeric_part" ]]; then
                continue
            fi
            
            # Generate new ID based on new mode
            local new_id=$(generate_new_task_id "$numeric_part" "$new_mode" 2>/dev/null)
            if [[ -z "$new_id" ]]; then
                continue
            fi
            
            # Add to mapping if IDs differ
            if [[ "$full_task_id" != "$new_id" ]]; then
                id_mapping["$full_task_id"]="$new_id"
                tasks_found=$((tasks_found + 1))
            fi
        fi
    done < "$TODO_FILE"
    
    if [[ $tasks_found -eq 0 ]]; then
        rm -f "$temp_file"
        return 0  # No tasks to renumber
    fi
    
    # Create new TODO.md with renumbered tasks
    local new_file=$(mktemp)
    local renumbered_count=0
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        local new_line="$line"
        local line_changed=false
        
        # Skip empty lines
        if [[ -z "$new_line" ]]; then
            echo "" >> "$new_file"
            continue
        fi
        
        # Replace task IDs in task lines (**#task_id**)
        for old_id in "${!id_mapping[@]}"; do
            local new_id="${id_mapping[$old_id]}"
            
            # Escape old_id for sed (escape special regex characters)
            local escaped_old_id=$(echo "$old_id" | sed 's/[[\.*^$()+?{|]/\\&/g')
            
            # Replace in task definition: **#old_id**
            if echo "$new_line" | grep -q "\*\*#${escaped_old_id}\*\*"; then
                new_line=$(echo "$new_line" | sed "s/\*\*#${escaped_old_id}\*\*/\*\*#${new_id}\*\*/g")
                line_changed=true
            fi
            
            # Replace in relationships and notes (plain text references)
            # Match: #old_id (standalone or in lists)
            if echo "$new_line" | grep -q "#${escaped_old_id}\([^0-9a-z-]\|$\)"; then
                new_line=$(echo "$new_line" | sed "s/#${escaped_old_id}\([^0-9a-z-]\|$\)/#${new_id}\1/g")
                line_changed=true
            fi
            
            # Replace in relationship comments (HTML comments)
            if echo "$new_line" | grep -q "${escaped_old_id}:"; then
                new_line=$(echo "$new_line" | sed "s/${escaped_old_id}:/${new_id}:/g")
                line_changed=true
            fi
        done
        
        if [[ "$line_changed" == true ]]; then
            renumbered_count=$((renumbered_count + 1))
        fi
        
        echo "$new_line" >> "$new_file"
    done < "$TODO_FILE"
    
    # Replace original file
    mv "$new_file" "$TODO_FILE"
    rm -f "$temp_file"
    
    if [[ $renumbered_count -gt 0 ]]; then
        update_footer
        return 0
    else
        return 1
    fi
}

# Switch numbering mode
switch_mode() {
    local new_mode="$1"
    local force=false
    local renumber=false
    local original_args=("$@")
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f)
                force=true
                shift
                ;;
            --renumber)
                renumber=true
                shift
                ;;
            *)
                if [[ -z "$new_mode" ]]; then
                    new_mode="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$new_mode" ]]; then
        echo "Error: Please specify a mode to switch to"
        echo "Usage: ./todo.ai switch-mode <mode> [--force] [--renumber]"
        echo "Modes: single-user, multi-user, branch, enhanced"
        echo "Options:"
        echo "  --force      Force mode switch (skip validation)"
        echo "  --renumber   Renumber existing tasks to match new mode"
        return 1
    fi
    
    # Validate mode
    case "$new_mode" in
        "single-user"|"multi-user"|"branch"|"enhanced")
            ;;
        *)
            echo "Error: Invalid mode '$new_mode'"
            echo "Valid modes: single-user, multi-user, branch, enhanced"
            return 1
            ;;
    esac
    
    # Get current mode
    local current_mode=$(get_numbering_mode)
    
    # Check if already in requested mode
    if [[ "$current_mode" == "$new_mode" ]]; then
        echo "Already in mode: $new_mode"
        return 0
    fi
    
    # Create backup before switching
    echo "Creating backup before mode switch..."
    local backup_name=$(create_mode_backup)
    if [[ -z "$backup_name" ]]; then
        echo "Error: Failed to create backup. Aborting mode switch."
        return 1
    fi
    echo "âœ… Backup created: $backup_name"
    echo ""
    
    # Validate configuration for new mode
    local config_file=$(get_config_file)
    local config_dir=$(dirname "$config_file")
    
    # Ensure config directory exists
    mkdir -p "$config_dir" 2>/dev/null || return 1
    
    # Update or create config file
    if [[ -f "$config_file" ]]; then
        # Update existing config file
        # Try yq first
        if command -v yq >/dev/null 2>&1; then
            yq eval ".mode = \"$new_mode\"" -i "$config_file" 2>/dev/null || {
                # Fallback to Python
                if command -v python3 >/dev/null 2>&1; then
                    python3 <<EOF
import yaml
import sys
try:
    with open('$config_file', 'r') as f:
        config = yaml.safe_load(f) or {}
    config['mode'] = '$new_mode'
    with open('$config_file', 'w') as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)
except Exception as e:
    sys.exit(1)
EOF
                    if [[ $? -ne 0 ]]; then
                        echo "Error: Failed to update config file"
                        return 1
                    fi
                else
                    # Fallback to sed (simple mode update)
                    sed_inplace "s/^mode:.*/mode: $new_mode/" "$config_file" || {
                        # If mode line doesn't exist, add it
                        if ! grep -q "^mode:" "$config_file"; then
                            echo "mode: $new_mode" >> "$config_file"
                        else
                            echo "Error: Failed to update config file"
                            return 1
                        fi
                    }
                fi
            }
        else
            # Fallback to Python or sed
            if command -v python3 >/dev/null 2>&1 && python3 -c "import yaml" 2>/dev/null; then
                python3 <<EOF
import yaml
import sys
try:
    with open('$config_file', 'r') as f:
        config = yaml.safe_load(f) or {}
    config['mode'] = '$new_mode'
    with open('$config_file', 'w') as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)
except Exception as e:
    sys.exit(1)
EOF
                if [[ $? -ne 0 ]]; then
                    echo "Error: Failed to update config file"
                    return 1
                fi
            else
                # Fallback to sed (simple mode update)
                sed_inplace "s/^mode:.*/mode: $new_mode/" "$config_file" || {
                    if ! grep -q "^mode:" "$config_file"; then
                        echo "mode: $new_mode" >> "$config_file"
                    else
                        echo "Error: Failed to update config file"
                        return 1
                    fi
                }
            fi
        fi
    else
        # Create new config file
        cat > "$config_file" <<EOF
# todo.ai Configuration File
# This file configures the task numbering system for this repository

# Mode: single-user | multi-user | branch | enhanced
mode: $new_mode

# Coordination settings (for enhanced mode)
coordination:
  type: none
  fallback: multi-user

# Conflict resolution settings
conflict_resolution:
  enabled: true
  auto_resolve: true
  renumber_on_conflict: true
  notify_on_conflict: false

# Display settings
display:
  show_prefix: false
  user_reference_style: number-only
EOF
    fi
    
    # Validate new configuration
    if ! validate_config; then
        echo "Error: Invalid configuration after mode switch"
        echo "Attempting to restore from backup..."
        rollback_from_backup "$backup_name" >/dev/null 2>&1 || true
        return 1
    fi
    
    # Optionally renumber tasks
    if [[ "$renumber" == true ]]; then
        echo ""
        echo "ðŸ”„ Renumbering tasks to match new mode..."
        if ! renumber_tasks_for_mode "$current_mode" "$new_mode"; then
            echo "âš ï¸  Warning: Task renumbering encountered issues"
            echo "   Some tasks may not have been renumbered correctly"
            echo "   Backup available: $backup_name"
        else
            echo "âœ… Tasks renumbered successfully"
        fi
        echo ""
    fi
    
    # Log the action
    log_todo_action "MODE_SWITCH" "$current_mode â†’ $new_mode" "Switched from $current_mode to $new_mode"
    
    echo "âœ… Mode switched: $current_mode â†’ $new_mode"
    echo ""
    if [[ "$renumber" == false ]]; then
        echo "ðŸ“ Note: Existing tasks keep their current IDs"
        echo "   New tasks will use the $new_mode numbering scheme"
        echo "   Use --renumber flag to renumber existing tasks"
    else
        echo "ðŸ“ All tasks have been renumbered to match $new_mode numbering scheme"
    fi
    echo ""
    echo "ðŸ’¾ Backup saved as: $backup_name"
    echo "   To rollback: ./todo.ai rollback-mode $backup_name"
    
    return 0
}

# Function to get next serial number
increment_serial() {
    # Ensure .todo.ai directory exists
    local serial_dir=$(dirname "$SERIAL_FILE")
    if [[ ! -d "$serial_dir" ]]; then
        mkdir -p "$serial_dir" 2>/dev/null || return 1
    fi
    
    if [[ -f "$SERIAL_FILE" ]]; then
        local current=$(cat "$SERIAL_FILE")
        local next=$((current + 1))
        echo "$next" > "$SERIAL_FILE"
        echo "$next"
    else
        echo "1" > "$SERIAL_FILE"
        echo "1"
    fi
}

# Function to update the Last Updated date in the footer
update_footer() {
    local current_date=$(date)
    # Update the Last Updated line in the footer
    sed_inplace "s/\*\*Last Updated:\*\* .*/\*\*Last Updated:\*\* $current_date/" "$TODO_FILE"
}

# Function to log TODO operations
log_todo_action() {
    # Ensure .todo.ai directory exists
    local log_dir=$(dirname "$LOG_FILE")
    if [[ ! -d "$log_dir" ]]; then
        mkdir -p "$log_dir" 2>/dev/null || return 1
    fi
    
    local action="$1"
    local task_id="$2"
    local description="$3"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local git_user=$(git config --get user.name 2>/dev/null || echo "unknown")
    
    # Create log entry in format: TIMESTAMP | USER | ACTION | TASK_ID | DESCRIPTION
    local log_entry="$timestamp | $git_user | $action | $task_id | $description"
    
    # Create temporary file with header preserved at top, then new entry, then existing entries
    local temp_file=$(mktemp)
    
    # Extract header lines (lines starting with #)
    grep "^#" "$LOG_FILE" > "$temp_file" || true
    echo "" >> "$temp_file"
    
    # Add new entry
    echo "$log_entry" >> "$temp_file"
    
    # Add existing log entries (skip header lines)
    grep -v "^#" "$LOG_FILE" | grep -v "^$" >> "$temp_file" || true
    
    mv "$temp_file" "$LOG_FILE"
}

# Function to initialize log file if it doesn't exist
init_log_file() {
    # Ensure .todo.ai directory exists
    local log_dir=$(dirname "$LOG_FILE")
    if [[ ! -d "$log_dir" ]]; then
        mkdir -p "$log_dir" 2>/dev/null || return 1
    fi
    
    if [[ ! -f "$LOG_FILE" ]]; then
        echo "# TODO Tool Log File" > "$LOG_FILE"
        echo "# Format: TIMESTAMP | USER | ACTION | TASK_ID | DESCRIPTION" >> "$LOG_FILE"
        echo "# Generated: $(date)" >> "$LOG_FILE"
        echo "" >> "$LOG_FILE"
    fi
}

# Function to initialize TODO file if it doesn't exist
init_todo_file() {
    if [[ ! -f "$TODO_FILE" ]]; then
        # Detect repository name and URL from git
        local repo_name="Project"
        local repo_url=""
        
        # Try to get repository name from git remote
        if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
            local remote_url=$(git remote get-url origin 2>/dev/null || echo "")
            if [[ -n "$remote_url" ]]; then
                # Extract repository name from URL (handle both https:// and git@ formats)
                if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
                    repo_name="${match[2]}"
                    # Remove .git suffix if present
                    repo_name="${repo_name%.git}"
                    # Convert to title case (first letter uppercase)
                    repo_name="$(echo "${repo_name:0:1}" | tr '[:lower:]' '[:upper:]')${repo_name:1}"
                    # Clean up URL (remove .git suffix if present, ensure https://)
                    repo_url="${remote_url%.git}"
                    if [[ ! "$repo_url" =~ ^https:// ]]; then
                        # Convert git@ format to https://
                        repo_url=$(echo "$repo_url" | sed 's/git@github\.com:/https:\/\/github.com\//')
                    fi
                fi
            fi
        fi
        
        cat > "$TODO_FILE" << EOF
# ${repo_name} ToDo List

> **âš ï¸ IMPORTANT: This file should ONLY be edited through the \`todo.ai\` script!**

## Tasks

------------------

## Recently Completed

---

**Last Updated:** $(date)
EOF
        # Add repository URL if detected
        if [[ -n "$repo_url" ]]; then
            echo "**Repository:** ${repo_url}  " >> "$TODO_FILE"
        fi
        echo "**Maintenance:** Use \`todo.ai\` script only" >> "$TODO_FILE"
        
        # Replace the $(date) placeholder with actual date
        local current_date=$(date)
        sed_inplace "s/\$(date)/$current_date/" "$TODO_FILE"
    fi
}

# Function to ensure Cursor rules include todo.ai requirement
init_cursor_rules() {
    local rules_dir="$(pwd)/.cursor/rules"
    local cursor_rules_file="$(pwd)/.cursorrules"
    local rules_created=0
    local rules_updated=0
    
    # Detect installation path for dynamic substitution in rules
    local todo_ai_path=$(get_todo_ai_path_for_rules)
    
    # If .cursorrules exists but .cursor/rules/ doesn't, let migration handle it
    if [[ -f "$cursor_rules_file" ]] && [[ ! -d "$rules_dir" ]]; then
        # Migration will handle the conversion, we just need to ensure rules directory exists
        mkdir -p "$rules_dir" 2>/dev/null || return 1
        return 0
    fi
    
    # Create .cursor/rules/ directory if it doesn't exist
    mkdir -p "$rules_dir" 2>/dev/null || return 1
    
    # Define end-user rule files (shipped with tool)
    local task_mgmt_file="${rules_dir}/todo.ai-task-management.mdc"
    local installation_file="${rules_dir}/todo.ai-installation.mdc"
    local bug_reporting_file="${rules_dir}/todo.ai-bug-reporting.mdc"
    local uninstall_file="${rules_dir}/todo.ai-uninstall.mdc"
    local commit_format_file="${rules_dir}/todo.ai-commit-format.mdc"
    
    # Task Management rule content
    local task_mgmt_content="It is required to track tasks and subtasks using todo.ai and not via built in TODO tools
TODO.md and .todo.ai/ must always be committed together
Always ask for user confirmation before archiving completed tasks using todo.ai"
    
    # Installation rule content (with detected path)
    local installation_content="When installing todo.ai from https://github.com/fxstein/todo.ai, use curl to download the single file: \`curl -o todo.ai https://raw.githubusercontent.com/fxstein/todo.ai/main/todo.ai && chmod +x todo.ai\`. Do NOT clone the repository with git clone - only the single todo.ai file is needed.

To update an existing installation, run: \`$todo_ai_path update\`"
    
    # Bug Reporting rule content (with detected path)
    local bug_reporting_content="When todo.ai encounters errors or unexpected behavior, or when the user asks to report a bug:

**CRITICAL REQUIREMENTS:**
1. **MUST use \`$todo_ai_path report-bug\` command** - This is the ONLY way to report bugs about todo.ai
2. **NEVER use \`gh issue create\` directly** - This bypasses all safeguards and duplicate detection
3. **NEVER use GitHub API directly** for bug reports - Always go through the bug reporting feature
4. Always require explicit user confirmation before any GitHub API calls
5. Show preview of bug report before asking for confirmation
6. Respect privacy: For private repositories, remove all repo identifiers

**Usage:**
\`\`\`bash
$todo_ai_path report-bug \"Error description\" \"Error context\" \"command\"
\`\`\`

**Examples:**
- âœ… User says \"report a bug about X\": Use \`$todo_ai_path report-bug \"X\" \"context\" \"command\"\`
- âœ… \"An error occurred. Would you like me to report this bug?\" â†’ If yes, use \`$todo_ai_path report-bug\`
- âŒ \"Error occurred. Automatically reporting to GitHub...\" (NEVER DO THIS)
- âŒ Using \`gh issue create\` directly for bug reports (NEVER DO THIS)
- âŒ Creating GitHub issues manually with \`gh CLI\` for todo.ai bugs (NEVER DO THIS)

**Why this is required:**
- The bug reporting feature includes duplicate detection
- It ensures proper formatting and context collection
- It maintains user control and privacy protection
- It follows the designed workflow for bug tracking"
    
    # Uninstall rule content (with detected path)
    local uninstall_content="When uninstalling todo.ai, or when the user asks to remove or delete todo.ai:

**CRITICAL REQUIREMENTS:**
1. **MUST use \`$todo_ai_path uninstall\` command** - This is the ONLY way to uninstall todo.ai
2. **NEVER delete files directly** - Do NOT use \`rm\`, \`rmdir\`, or file deletion commands on:
   - The todo.ai script file
   - The .todo.ai/ data directory
   - The .cursor/rules/todo.ai-*.mdc rule files
3. **NEVER use file system operations directly** - Always go through the uninstall feature
4. Always require explicit user confirmation before any uninstall operations
5. Show preview of what will be removed before asking for confirmation
6. Control uninstall scope: The uninstall command provides options to control what gets removed

**Usage:**
\`\`\`bash
$todo_ai_path uninstall                  # Remove script only (preserves data and rules)
$todo_ai_path uninstall --remove-data   # Remove script and data directory
$todo_ai_path uninstall --remove-rules  # Remove script and Cursor rules
$todo_ai_path uninstall --all           # Remove everything (script + data + rules)
\`\`\`

**Examples:**
- âœ… User says \"uninstall todo.ai\": Use \`$todo_ai_path uninstall\`
- âœ… User says \"remove todo.ai and data\": Use \`$todo_ai_path uninstall --remove-data\`
- âœ… User says \"delete todo.ai completely\": Use \`$todo_ai_path uninstall --all\`
- âŒ \"Removing todo.ai files...\" and using \`rm todo.ai\` (NEVER DO THIS)
- âŒ Using \`rm -rf .todo.ai\` directly (NEVER DO THIS)
- âŒ Deleting .cursor/rules/todo.ai-*.mdc files manually (NEVER DO THIS)

**Why this is required:**
- The uninstall feature ensures safe removal with proper scope control
- It prevents accidental deletion of user data
- It provides clear preview and confirmation before removal
- It maintains proper cleanup of all todo.ai components
- It preserves TODO.md files (never removed by uninstall)"
    
    # Commit Format rule content
    local commit_format_content="When referencing todo.ai task numbers in commit messages:

**CRITICAL REQUIREMENTS:**
1. **MUST use \`task#nn\` format** (e.g., \`task#15\`, \`task#50\`) when referencing todo.ai task numbers
2. **NEVER use \`#nn\` format** for task numbers - this causes GitHub to auto-link to issues/PRs
3. Always use the \`task#\` prefix before task numbers to prevent GitHub auto-linking

**Format Examples:**
- âœ… Correct: \`feat: Implement git hooks with pre-commit validation (task#15)\`
- âœ… Correct: \`Archive completed task#15 (git hooks), delete task#21\`
- âœ… Correct: \`feat: Add automated linter setup script (task#15.8, task#15.9)\`
- âŒ Incorrect: \`feat: Implement git hooks (#15)\` - will auto-link to issue #15
- âŒ Incorrect: \`feat: Implement git hooks (task #15)\` - space breaks pattern

**Why this is required:**
- GitHub automatically links \`#number\` patterns to issues and pull requests
- Task numbers like \`#15\` conflict with GitHub issue numbers
- Using \`task#15\` prevents auto-linking and eliminates confusion
- Keeps commit history clear and accurate"
    
    # Create or update Task Management rule
    if [[ ! -f "$task_mgmt_file" ]]; then
        cat > "$task_mgmt_file" << EOF
---
description: "Task management rules for todo.ai"
alwaysApply: true
---
$task_mgmt_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date (contains key indicators)
        if ! grep -q "track tasks" "$task_mgmt_file" || ! grep -q "committed together" "$task_mgmt_file" || ! grep -q "archiving completed tasks" "$task_mgmt_file"; then
            # Update existing file
            cat > "$task_mgmt_file" << EOF
---
description: "Task management rules for todo.ai"
alwaysApply: true
---
$task_mgmt_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Create or update Installation rule
    if [[ ! -f "$installation_file" ]]; then
        cat > "$installation_file" << EOF
---
description: "Installation instructions for todo.ai"
alwaysApply: true
---
$installation_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date
        if ! grep -q "curl -o todo.ai" "$installation_file"; then
            # Update existing file
            cat > "$installation_file" << EOF
---
description: "Installation instructions for todo.ai"
alwaysApply: true
---
$installation_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Create or update Bug Reporting rule
    if [[ ! -f "$bug_reporting_file" ]]; then
        cat > "$bug_reporting_file" << EOF
---
description: "Bug reporting rules for todo.ai"
alwaysApply: true
---
$bug_reporting_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date (contains key indicators)
        if ! grep -q "CRITICAL REQUIREMENTS" "$bug_reporting_file" || ! grep -q "MUST use.*report-bug" "$bug_reporting_file" || ! grep -q "NEVER use.*gh issue create" "$bug_reporting_file"; then
            # Update existing file
            cat > "$bug_reporting_file" << EOF
---
description: "Bug reporting rules for todo.ai"
alwaysApply: true
---
$bug_reporting_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Create or update Uninstall rule
    if [[ ! -f "$uninstall_file" ]]; then
        cat > "$uninstall_file" << EOF
---
description: "Uninstall rules for todo.ai"
alwaysApply: true
---
$uninstall_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date (contains key indicators)
        if ! grep -q "CRITICAL REQUIREMENTS" "$uninstall_file" || ! grep -q "MUST use.*uninstall" "$uninstall_file" || ! grep -q "NEVER delete files directly" "$uninstall_file"; then
            # Update existing file
            cat > "$uninstall_file" << EOF
---
description: "Uninstall rules for todo.ai"
alwaysApply: true
---
$uninstall_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Create or update Commit Format rule
    if [[ ! -f "$commit_format_file" ]]; then
        cat > "$commit_format_file" << EOF
---
description: "Commit message format rules for todo.ai task references"
alwaysApply: true
---
$commit_format_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date (contains key indicators)
        if ! grep -q "CRITICAL REQUIREMENTS" "$commit_format_file" || ! grep -q "MUST use.*task#" "$commit_format_file" || ! grep -q "NEVER use.*#nn" "$commit_format_file"; then
            # Update existing file
            cat > "$commit_format_file" << EOF
---
description: "Commit message format rules for todo.ai task references"
alwaysApply: true
---
$commit_format_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Show feedback if rules were created or updated
    if [[ $rules_created -gt 0 ]] || [[ $rules_updated -gt 0 ]]; then
        echo ""
        echo "âš ï¸  IMPORTANT: Cursor rules initialized"
        if [[ $rules_created -gt 0 ]]; then
            echo "   ðŸ“ Created $rules_created rule file(s) in .cursor/rules/"
        fi
        if [[ $rules_updated -gt 0 ]]; then
            echo "   ðŸ“ Updated $rules_updated rule file(s) in .cursor/rules/"
        fi
        echo "   This ensures AI agents will automatically use todo.ai for task tracking"
        echo ""
        echo "   ðŸ”„ ACTION REQUIRED: Cursor rules have been initialized!"
        echo ""
        echo "   For Humans:"
        echo "   â†’ Please start a new chat session in Cursor"
        echo "   â†’ Cursor only loads rules at the start of each chat session"
        echo "   â†’ The rules will not apply to your current session"
        echo ""
        echo "   For AI Agents:"
        echo "   â†’ Inform the user that cursor rules have been initialized"
        echo "   â†’ Request that the user start a new chat session"
        echo "   â†’ The rules will only take effect in a new session"
    fi
    
    return 0
}

# Function to get current serial number
get_current_serial() {
    if [[ -f "$SERIAL_FILE" ]]; then
        cat "$SERIAL_FILE"
    else
        echo "0"
    fi
}

# Function to parse task line and extract components
parse_task() {
    local line="$1"
    local id=$(echo "$line" | grep -o '^#\([0-9.]*\)' | sed 's/#//')
    local description=$(echo "$line" | sed 's/^#[0-9.]* *//' | sed 's/ *#.*$//')
    local tags=$(echo "$line" | grep -o '#[a-zA-Z0-9]*' | grep -v '^#[0-9]' | tr '\n' ' ')
    local date=$(echo "$line" | grep -o '([^)]*)' | tr -d '()')
    
    echo "ID:$id|DESC:$description|TAGS:$tags|DATE:$date"
}

# Function to normalize malformed checkboxes
normalize_checkboxes() {
    # Fix malformed checkboxes like [  ], [   ], [] to proper [ ] or [x]
    sed_inplace 's/\[  \]/[ ]/g' "$TODO_FILE"
    sed_inplace 's/\[   \]/[ ]/g' "$TODO_FILE"
    sed_inplace 's/\[    \]/[ ]/g' "$TODO_FILE"
    sed_inplace 's/\[\]/[ ]/g' "$TODO_FILE"
    # Fix any other malformed patterns with multiple spaces
    sed_inplace 's/\[[ ]*\]/[ ]/g' "$TODO_FILE"
}

# Function to show usage
show_usage() {
    echo "Usage: ./todo.ai [command] [options]"
    echo ""
    echo "Version: $VERSION"
    echo ""
    echo "Commands:"
    echo "  add <text> [tags]             Add a new todo item with optional tags"
    echo "  add-subtask <parent-id> <text> [tags]  Add a subtask to an existing task (supports 2-level nesting)"
    echo "  list [--tag <tag>] [--incomplete-only] [--parents-only] [--has-subtasks]  Show todo list with filters"
    echo "  complete <id> [<id>...] [--with-subtasks]  Mark item(s) as completed"
    echo "  undo <id>                     Reopen (undo) completed task (use #ID)"
    echo "  modify <id> <text> [tags]     Modify task description and/or tags"
    echo "  delete <id> [<id>...] [--with-subtasks]  Soft delete task(s) to Deleted section (30-day recovery)"
    echo "  archive <id> [<id>...] [--reason <reason>]  Move task(s) to Recently Completed (reason for incomplete tasks)"
    echo "  relate <id> --<type> <targets>  Add task relationship (completed-by, depends-on, blocks, related-to, duplicate-of)"
    echo "  note <id> <text>              Add note to task (blockquote format)"
    echo "  show <id>                     Show task with subtasks, relationships, and notes"
    echo "  restore <id>                  Restore task from Deleted or Recently Completed to active Tasks"
    echo "  --lint                        Identify formatting issues (indentation, checkboxes)"
    echo "  --reformat [--dry-run]        Apply formatting fixes (use --dry-run to preview)"
    echo "  resolve-conflicts [--dry-run] Detect and resolve duplicate task IDs (optional dry-run)"
    echo "  edit                          Edit todo file in editor"
    echo "  log [--filter <text>] [--lines <n>] View TODO operation log"
    echo "  update                        Update todo.ai to latest version"
    echo "  backups, list-backups         List available backup versions"
    echo "  rollback [index|timestamp]    Rollback to previous version (default: latest backup)"
    echo "  report-bug \"description\"      Report a bug to GitHub Issues (requires GitHub CLI)"
    echo "  uninstall [--remove-data] [--remove-rules] [--all]  Uninstall todo.ai"
    echo "  switch-mode <mode> [--force] [--renumber]  Switch numbering mode (single-user, multi-user, branch, enhanced)"
    echo "  list-mode-backups             List mode switch backups"
    echo "  rollback-mode <backup-name>   Rollback from mode switch backup"
    echo "  version, -v, --version        Show version information"
    echo ""
    echo ""
    echo "Examples:"
    echo "  ./todo.ai add 'Fix Shelly device naming' '#api'"
    echo "  ./todo.ai add-subtask 39 'Design subtask data structure' '#feature'"
    echo "  ./todo.ai add-subtask 39.1 'Create nested subtask' '#test'    # 2-level nesting"
    echo "  ./todo.ai complete 1"
    echo "  ./todo.ai complete 107 108 109          # Bulk complete"
    echo "  ./todo.ai complete 104 --with-subtasks  # Complete task and all subtasks"
    echo "  ./todo.ai complete 104.3-104.10         # Complete range of subtasks"
    echo "  ./todo.ai undo 1"
    echo "  ./todo.ai modify 1 'Updated task description' '#api'"
    echo "  ./todo.ai delete 115                    # Soft delete (30-day recovery)"
    echo "  ./todo.ai delete 110 --with-subtasks    # Delete task and all subtasks"
    echo "  ./todo.ai delete 120.5-120.10           # Delete range"
    echo "  ./todo.ai archive 1"
    echo "  ./todo.ai archive 107 108 109           # Bulk archive"
    echo "  ./todo.ai archive 109 --reason obsolete # Archive incomplete task"
    echo "  ./todo.ai archive 104 --reason 'completed-by:107,108'"
    echo "  ./todo.ai relate 110 --depends-on 104  # Add dependency"
    echo "  ./todo.ai relate 104 --completed-by '107,108'"
    echo "  ./todo.ai note 110 'Testing shows issues'  # Add note"
    echo "  ./todo.ai show 110                    # Show task with relationships & notes"
    echo "  ./todo.ai restore 1"
    echo "  ./todo.ai --lint"
    echo "  ./todo.ai --reformat --dry-run"
    echo "  ./todo.ai --reformat"
    echo "  ./todo.ai resolve-conflicts --dry-run  # Preview conflict resolution"
    echo "  ./todo.ai resolve-conflicts            # Resolve duplicate task IDs"
    echo "  ./todo.ai list"
    echo "  ./todo.ai list --tag api"
    echo "  ./todo.ai list --incomplete-only     # Show only pending tasks"
    echo "  ./todo.ai list --parents-only        # Hide subtasks"
    echo "  ./todo.ai list --has-subtasks        # Only tasks with subtasks"
    echo "  ./todo.ai log"
    echo "  ./todo.ai log --filter ADD"
    echo "  ./todo.ai log --lines 20"
    echo "  ./todo.ai update                     # Update to latest version"
    echo "  ./todo.ai backups                    # List available backups"
    echo "  ./todo.ai rollback                   # Rollback to latest backup"
    echo "  ./todo.ai rollback 2                 # Rollback to backup #2"
    echo "  ./todo.ai rollback 20251030231500     # Rollback by timestamp"
    echo "  ./todo.ai report-bug \"Error message\" # Report bug to GitHub Issues"
    echo "  ./todo.ai uninstall                  # Uninstall script only"
    echo "  ./todo.ai uninstall --all             # Uninstall script, data, and rules"
    echo "  ./todo.ai switch-mode multi-user     # Switch to multi-user numbering mode"
    echo "  ./todo.ai switch-mode multi-user --renumber  # Switch and renumber existing tasks"
    echo "  ./todo.ai switch-mode branch          # Switch to branch-based numbering"
    echo "  ./todo.ai list-mode-backups           # List mode switch backups"
    echo "  ./todo.ai rollback-mode <backup-name> # Rollback from mode switch"
    echo "  ./todo.ai version                    # Show version"
    echo ""
    echo "Copyright 2025 Oliver Ratzesberger"
    echo "Licensed under the Apache License, Version 2.0"
    echo "Repository: $REPO_URL"
}

# Function to validate command arguments and detect invalid options
validate_command_args() {
    local command="$1"
    shift
    local args=("$@")
    
    case "$command" in
        "add")
            # add <text> [tags] - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'add' command"
                    echo "The 'add' command only accepts text and optional tags"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "add-subtask")
            # add-subtask <parent-id> <text> [tags] - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'add-subtask' command"
                    echo "The 'add-subtask' command only accepts parent-id, text, and optional tags"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "list")
            # list [--tag <tag>] [--incomplete-only] [--parents-only] [--has-subtasks]
            local expecting_tag=false
            for arg in "${args[@]}"; do
                if [[ "$arg" == "--tag" ]]; then
                    expecting_tag=true
                elif [[ "$arg" =~ ^--(incomplete-only|parents-only|has-subtasks)$ ]]; then
                    # Valid flags
                    continue
                elif [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'list' command"
                    echo "The 'list' command accepts: --tag <tag>, --incomplete-only, --parents-only, --has-subtasks"
                    echo ""
                    show_usage
                    return 1
                elif [[ "$expecting_tag" == true ]]; then
                    expecting_tag=false
                fi
            done
            ;;
        "complete")
            # complete <id> [<id>...] [--with-subtasks] - allow multiple IDs and --with-subtasks flag
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]] && [[ "$arg" != "--with-subtasks" ]]; then
                    echo "Error: Invalid option '$arg' for 'complete' command"
                    echo "The 'complete' command accepts task ID(s) and optional --with-subtasks flag"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "undo")
            # undo <id> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'undo' command"
                    echo "The 'undo' command only accepts a task ID"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "modify")
            # modify <id> <text> [tags] - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'modify' command"
                    echo "The 'modify' command only accepts task-id, text, and optional tags"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "archive")
            # archive <id> [<id>...] [--reason <reason>] - allow multiple IDs and reason
            local expecting_reason=false
            for arg in "${args[@]}"; do
                if [[ "$arg" == "--reason" ]]; then
                    expecting_reason=true
                elif [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'archive' command"
                    echo "The 'archive' command accepts task ID(s) and optional --reason <reason>"
                    echo ""
                    show_usage
                    return 1
                elif [[ "$expecting_reason" == true ]]; then
                    expecting_reason=false
                fi
            done
            ;;
        "delete")
            # delete <id> [<id>...] [--with-subtasks] - allow multiple IDs and --with-subtasks
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]] && [[ "$arg" != "--with-subtasks" ]]; then
                    echo "Error: Invalid option '$arg' for 'delete' command"
                    echo "The 'delete' command accepts task ID(s) and optional --with-subtasks flag"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "relate")
            # relate <id> --<relation-type> <targets> - relationship management
            # Allow all --completed-by, --depends-on, --blocks, --related-to, --duplicate-of
            ;;
        "note")
            # note <id> <text> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'note' command"
                    echo "The 'note' command only accepts task ID and note text"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "show")
            # show <id> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'show' command"
                    echo "The 'show' command only accepts a task ID"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "restore")
            # restore <id> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'restore' command"
                    echo "The 'restore' command only accepts a task ID"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "log")
            # log [--filter <text>] [--lines <n>] - only --filter and --lines allowed
            local expecting_filter=false
            local expecting_lines=false
            for arg in "${args[@]}"; do
                if [[ "$arg" == "--filter" ]]; then
                    expecting_filter=true
                elif [[ "$arg" == "--lines" ]]; then
                    expecting_lines=true
                elif [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'log' command"
                    echo "The 'log' command only accepts --filter <text> and --lines <n> options"
                    echo ""
                    show_usage
                    return 1
                elif [[ "$expecting_filter" == true ]]; then
                    expecting_filter=false
                elif [[ "$expecting_lines" == true ]]; then
                    expecting_lines=false
                fi
            done
            ;;
    esac
    
    return 0
}

# Function to add todo item
add_todo() {
    local text="$1"
    local tags="$2"
    
    if [[ -z "$text" ]]; then
        echo "Error: Please provide todo text"
        return 1
    fi
    
    # Validate configuration before proceeding
    if ! validate_config; then
        echo "âš ï¸  Configuration error detected. Using default mode (single-user)." >&2
    fi
    
    # Get next task number based on current mode
    local task_id=$(assign_task_number)
    
    # Format the task line with bold task ID
    local task_line="- [ ] **#$task_id** $text"
    if [[ -n "$tags" ]]; then
        # Wrap each tag in backticks for code styling
        local styled_tags=""
        # Split tags by space and process each one
        for tag in $(echo "$tags" | tr ' ' '\n'); do
            if [[ -n "$styled_tags" ]]; then
                styled_tags="$styled_tags \`$tag\`"
            else
                styled_tags="\`$tag\`"
            fi
        done
        task_line="$task_line $styled_tags"
    fi
    
    # Add to Tasks section
    local tasks_line=$(grep -n "^## Tasks" "$TODO_FILE" | cut -d: -f1)
    if [[ -n "$tasks_line" ]]; then
        # Use awk or a simpler approach for macOS compatibility
        if [[ "$(uname)" == "Darwin" ]]; then
            # Insert after the ## Tasks line with proper newline
            local temp_file=$(mktemp)
            head -n "$tasks_line" "$TODO_FILE" > "$temp_file"
            echo "$task_line" >> "$temp_file"
            tail -n +$((tasks_line + 1)) "$TODO_FILE" >> "$temp_file"
            mv "$temp_file" "$TODO_FILE"
        else
            sed_inplace "/^## Tasks$/a$task_line" "$TODO_FILE"
        fi
    fi
    update_footer
    
    # Log the action
    log_todo_action "ADD" "$task_id" "$text"
    
    echo "Added: #$task_id $text"
}

# Function to calculate nesting depth from task ID
get_nesting_depth() {
    local task_id="$1"
    # Count the number of dots in the task ID
    local depth=$(echo "$task_id" | tr -cd '.' | wc -c | tr -d ' ')
    # Depth is number of dots (0 for main tasks like "1", 1 for "1.1", 2 for "1.1.1")
    echo "$depth"
}

# Function to add subtask to existing task (supports nested subtasks up to 2 levels)
add_subtask() {
    local parent_id="$1"
    local text="$2"
    local tags="$3"
    
    if [[ -z "$parent_id" || -z "$text" ]]; then
        echo "Error: Please provide parent task ID and subtask text"
        echo "Usage: ./todo.ai add-subtask <parent-id> \"<subtask text>\" [\"<tags>\"]"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_parent_id=$(resolve_task_reference "$parent_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_parent_id" ]]; then
        resolved_parent_id="$parent_id"
    fi
    parent_id="$resolved_parent_id"
    
    # Check nesting depth of parent
    local parent_depth=$(get_nesting_depth "$parent_id")
    
    # Validate max nesting (2 levels: main task â†’ subtask â†’ sub-subtask)
    if [[ $parent_depth -ge 2 ]]; then
        echo "Error: Cannot add subtask to #$parent_id"
        echo "   Maximum nesting depth is 2 levels (main task â†’ subtask â†’ sub-subtask)"
        echo "   Task #$parent_id is already at the maximum depth"
        return 1
    fi
    
    # Check if parent task exists (can be main task or subtask)
    local parent_found=false
    local parent_line_num=""
    local parent_indent=""
    
    # Check for main task pattern: `^- \[.*\] \*\*#$parent_id\*\* `
    if grep -q "^- \[.*\] \*\*#$parent_id\*\* " "$TODO_FILE"; then
        parent_found=true
        parent_line_num=$(grep -n "^- \[.*\] \*\*#$parent_id\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
        parent_indent="  "  # Main tasks have subtasks indented with 2 spaces
    # Check for subtask pattern: `^  - \[.*\] \*\*#$parent_id\*\* `
    elif grep -q "^  - \[.*\] \*\*#$parent_id\*\* " "$TODO_FILE"; then
        parent_found=true
        parent_line_num=$(grep -n "^  - \[.*\] \*\*#$parent_id\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
        parent_indent="    "  # Subtasks have sub-subtasks indented with 4 spaces
    fi
    
    if [[ "$parent_found" == false ]]; then
        echo "Error: Parent task #$parent_id not found"
        return 1
    fi
    
    # Find the next subtask number for this parent
    local next_subtask_num=1
    local subtask_pattern="^$parent_indent- \[.*\] \*\*#$parent_id\.$next_subtask_num\*\* "
    while grep -q "$subtask_pattern" "$TODO_FILE"; do
        next_subtask_num=$((next_subtask_num + 1))
        subtask_pattern="^$parent_indent- \[.*\] \*\*#$parent_id\.$next_subtask_num\*\* "
    done
    
    # Create subtask ID
    local subtask_id="$parent_id.$next_subtask_num"
    
    # Format the subtask line with bold task ID and proper indentation
    local task_line="$parent_indent- [ ] **#$subtask_id** $text"
    if [[ -n "$tags" ]]; then
        # Wrap each tag in backticks for code styling
        local styled_tags=""
        # Split tags by space and process each one
        for tag in $(echo "$tags" | tr ' ' '\n'); do
            if [[ -n "$styled_tags" ]]; then
                styled_tags="$styled_tags \`$tag\`"
            else
                styled_tags="\`$tag\`"
            fi
        done
        task_line="$task_line $styled_tags"
    fi
    
    # Find the parent task line and add subtask after it (newest first)
    if [[ -n "$parent_line_num" ]]; then
        # Insert right after the parent line (newest subtasks appear first)
        local insert_line=$((parent_line_num + 1))
        local max_lines=$(wc -l < "$TODO_FILE" | tr -d ' ')
        
        if [[ "$(uname)" == "Darwin" ]]; then
            local temp_file=$(mktemp)
            if [[ $insert_line -gt $max_lines ]]; then
                # Append to end of file
                cat "$TODO_FILE" > "$temp_file"
                echo "$task_line" >> "$temp_file"
            else
                head -n $((insert_line - 1)) "$TODO_FILE" > "$temp_file"
                echo "$task_line" >> "$temp_file"
                tail -n +$insert_line "$TODO_FILE" >> "$temp_file"
            fi
            mv "$temp_file" "$TODO_FILE"
        else
            sed_inplace "${insert_line}i\\$task_line" "$TODO_FILE"
        fi
        update_footer
        
        # Log the action
        log_todo_action "ADD_SUBTASK" "$subtask_id" "$text (parent: #$parent_id)"
        
        local depth_label="subtask"
        if [[ $parent_depth -eq 1 ]]; then
            depth_label="sub-subtask"
        fi
        echo "Added $depth_label: #$subtask_id $text"
    else
        echo "Error: Could not find parent task #$parent_id"
        return 1
    fi
}

# Function to list todos
list_todos() {
    local filter_tag=""
    local incomplete_only=false
    local parents_only=false
    local has_subtasks_only=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tag)
                filter_tag="$2"
                shift 2
                ;;
            --incomplete-only)
                incomplete_only=true
                shift
                ;;
            --parents-only)
                parents_only=true
                shift
                ;;
            --has-subtasks)
                has_subtasks_only=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ ! -f "$TODO_FILE" ]]; then
        echo "Todo file not found: $TODO_FILE"
        return 1
    fi
    
    # If using tag filter, use original implementation
    if [[ -n "$filter_tag" ]] && [[ "$incomplete_only" == false ]] && [[ "$parents_only" == false ]] && [[ "$has_subtasks_only" == false ]]; then
        # Add # prefix if missing
        if [[ ! "$filter_tag" =~ ^# ]]; then
            filter_tag="#$filter_tag"
        fi
        
        # Filter by tag - show tasks with the specified tag
        # Escape special characters in filter_tag for regex matching
        local escaped_tag=$(echo "$filter_tag" | sed 's/[.*+?^${}()|\[\]\\]/\\&/g')
        
        echo "# Home Assistant Project Todo List"
        echo ""
        echo "## Tasks with tag: $filter_tag"
        echo ""
        # Match tags both with backticks (styled) and without (plain)
        # Match all task levels: main tasks (0 spaces), subtasks (2 spaces), sub-subtasks (4 spaces)
        grep -E "\`${escaped_tag}\`|${escaped_tag}" "$TODO_FILE" | grep -E "^-.*\[.*\]|^  -.*\[.*\]|^    -.*\[.*\]"
        echo ""
        echo "## Recently Completed with tag: $filter_tag"
        echo ""
        grep -E "\`${escaped_tag}\`|${escaped_tag}" "$TODO_FILE" | grep -E "^-.*\[x\]|^  -.*\[x\]|^    -.*\[x\]"
        return
    fi
    
    # Enhanced filtering logic
    local in_tasks_section=false
    local in_recently_completed=false
    local current_parent=""
    local parent_has_subtasks=false
    local last_parent_shown=false
    
    # First pass: identify parents with subtasks if needed
    local parents_with_subtasks=()
    if [[ "$has_subtasks_only" == true ]]; then
        while IFS= read -r line; do
            # Check if this is a subtask (starts with "  - ")
            if [[ "$line" =~ ^"  - ".+#([0-9]+)\.([0-9]+) ]]; then
                local parent_id="${match[1]}"
                if [[ ! " ${parents_with_subtasks[@]} " =~ " ${parent_id} " ]]; then
                    parents_with_subtasks+=("$parent_id")
                fi
            fi
        done < "$TODO_FILE"
    fi
    
    # Second pass: filter and display
    while IFS= read -r line; do
        # Track sections
        if [[ "$line" == "## Tasks" ]]; then
            in_tasks_section=true
            in_recently_completed=false
            if [[ "$incomplete_only" == false ]]; then
                echo "$line"
            fi
            continue
        elif [[ "$line" == "## Recently Completed" ]]; then
            in_tasks_section=false
            in_recently_completed=true
            if [[ "$incomplete_only" == false ]]; then
                echo "$line"
            fi
            continue
        elif [[ "$line" =~ ^## ]]; then
            # Other section, stop filtering
            if [[ "$incomplete_only" == false ]]; then
                echo "$line"
            fi
            in_tasks_section=false
            in_recently_completed=false
            continue
        fi
        
        # Skip completed section if --incomplete-only
        if [[ "$incomplete_only" == true ]] && [[ "$in_recently_completed" == true ]]; then
            continue
        fi
        
        # Check if this is a parent task (starts with "- [" and has **#num** but not **#num.num**)
        if [[ "$line" == "- ["*"**#"*"**"* ]] && [[ "$line" != *"**#"*"."*"**"* ]]; then
            # Extract task ID and checkbox
            local checkbox=$(echo "$line" | sed 's/^- \[\(.\)\].*/\1/')
            current_parent=$(echo "$line" | grep -o '#[0-9]\+' | sed 's/#//' | head -1)
            
            # Apply filters
            local should_show=true
            
            # Filter: incomplete only (skip completed tasks)
            if [[ "$incomplete_only" == true ]] && [[ "$checkbox" == "x" ]]; then
                should_show=false
            fi
            
            # Filter: has-subtasks only
            if [[ "$has_subtasks_only" == true ]]; then
                if [[ ! " ${parents_with_subtasks[@]} " =~ " ${current_parent} " ]]; then
                    should_show=false
                fi
            fi
            
            # Filter: tag (match both styled with backticks and plain)
            if [[ -n "$filter_tag" ]]; then
                if [[ ! "$filter_tag" =~ ^# ]]; then
                    filter_tag="#$filter_tag"
                fi
                # Check if line contains the tag (with or without backticks)
                if [[ ! "$line" =~ \`${filter_tag}\` ]] && [[ ! "$line" =~ ${filter_tag} ]]; then
                    should_show=false
                fi
            fi
            
            last_parent_shown=$should_show
            if [[ "$should_show" == true ]]; then
                echo "$line"
            fi
        # Check if this is a subtask (starts with "  - ")
        elif [[ "$line" =~ ^"  - " ]]; then
            # Show subtasks unless --parents-only, and only if parent was shown
            if [[ "$parents_only" == false ]] && [[ "$last_parent_shown" == true ]]; then
                # Apply same filters as parent
                local should_show=true
                
                # Tag filter (match both styled with backticks and plain)
                if [[ -n "$filter_tag" ]]; then
                    if [[ ! "$line" =~ \`${filter_tag}\` ]] && [[ ! "$line" =~ ${filter_tag} ]]; then
                        should_show=false
                    fi
                fi
                
                if [[ "$should_show" == true ]]; then
                    echo "$line"
                fi
            fi
        else
            # Non-task line (headers, footers, blank lines, etc.)
            # Only show if not heavily filtering
            if [[ "$incomplete_only" == false ]] && [[ "$parents_only" == false ]] && [[ "$has_subtasks_only" == false ]]; then
                echo "$line"
            elif [[ "$in_tasks_section" == true ]] || [[ "$line" == "" ]] || [[ "$line" =~ ^## ]]; then
                # Always show headers and blank lines in tasks section
                echo "$line"
            fi
        fi
    done < "$TODO_FILE"
}

# Function to get line number of task by serial number
get_task_line() {
    local task_id="$1"
    local line_number=0
    
    while IFS= read -r line; do
        line_number=$((line_number + 1))
        if [[ "$line" =~ "^-.*\[.*\].*" || "$line" =~ "^  -.*\[.*\].*" ]]; then
            # Extract the ID from the line (handle both bold and non-bold formatting, and subtasks)
            local line_id=$(echo "$line" | grep -o '\*\*#\([0-9][0-9.]*\)\*\*\|#[0-9][0-9.]*' | sed 's/\*\*#//g' | sed 's/\*\*//g' | sed 's/#//')
            if [[ "$line_id" == "$task_id" ]]; then
                echo "$line_number"
                return 0
            fi
        fi
    done < "$TODO_FILE"
    
    echo "Task #$task_id not found"
    return 1
}

# Function to mark as complete
complete_todo() {
    local with_subtasks=false
    local task_ids=()
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --with-subtasks)
                with_subtasks=true
                shift
                ;;
            *)
                task_ids+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ ${#task_ids[@]} -eq 0 ]]; then
        echo "Error: Please provide at least one task number"
        return 1
    fi
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Resolve task references and expand ranges
    local all_ids=()
    for id in "${task_ids[@]}"; do
        # Resolve task reference (auto-add prefix for number-only references)
        local resolved_id=$(resolve_task_reference "$id" 2>/dev/null)
        if [[ $? -ne 0 ]] || [[ -z "$resolved_id" ]]; then
            # If resolution failed, try using original ID (might be a range or already have prefix)
            resolved_id="$id"
        fi
        
        # Match range format: 104.3-104.10 or 122.3-10 (both formats supported)
        if [[ "$resolved_id" =~ ^([0-9]+)\.([0-9]+)-([0-9]+)\.([0-9]+)$ ]] || [[ "$resolved_id" =~ ^[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)-[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)$ ]]; then
            # Full format: 122.3-122.10
            local parent=${match[1]}
            local start=${match[2]}
            local end_parent=${match[3]}
            local end=${match[4]}
            # Verify parent IDs match
            if [[ "$parent" == "$end_parent" ]]; then
                for ((i=start; i<=end; i++)); do
                    all_ids+=("${parent}.${i}")
                done
            else
                echo "Warning: Range parent IDs don't match ($parent vs $end_parent), treating as literal"
                all_ids+=("$id")
            fi
        elif [[ "$id" =~ ^([0-9]+)\.([0-9]+)-([0-9]+)$ ]]; then
            # Short format: 122.3-10 (assumes same parent)
            local parent=${match[1]}
            local start=${match[2]}
            local end=${match[3]}
            for ((i=start; i<=end; i++)); do
                all_ids+=("${parent}.${i}")
            done
        else
            all_ids+=("$id")
        fi
    done
    
    # If --with-subtasks, add all subtasks for parent tasks (including nested subtasks)
    if [[ "$with_subtasks" == "true" ]]; then
        local expanded_ids=()
        for id in "${all_ids[@]}"; do
            expanded_ids+=("$id")
            # Find all subtasks and sub-subtasks for this parent
            # Check if this is a parent task (may or may not contain dots)
            local id_depth=$(get_nesting_depth "$id")
            
            # Find all direct subtasks and nested subtasks
            # Pattern matches: id.1, id.2, id.1.1, id.1.2, id.2.1, etc.
            while IFS= read -r line; do
                # Extract task ID from line (handles nested IDs)
                if [[ "$line" =~ '#([0-9]+(\.[0-9]+)+)' ]]; then
                    local task_id="${match[1]}"
                    # Check if this task belongs to our parent (direct or nested subtask)
                    # For main task 1, match: 1.1, 1.2, 1.1.1, 1.1.2, etc.
                    # For subtask 1.1, match: 1.1.1, 1.1.2, etc.
                    if [[ "$task_id" =~ ^$id\. ]]; then
                        expanded_ids+=("$task_id")
                    fi
                fi
            done < "$TODO_FILE"
        done
        all_ids=("${expanded_ids[@]}")
    fi
    
    # Complete all tasks
    local completed_count=0
    for number in "${all_ids[@]}"; do
        # Skip if task doesn't exist (escape asterisks for grep)
        if ! grep -q "\*\*#$number\*\*" "$TODO_FILE"; then
            echo "Warning: Task #$number not found, skipping"
            continue
        fi
        
        # Complete the task
        sed_inplace "s/- \[ \] \*\*#$number\*\* /- [x] **#$number** /" "$TODO_FILE"
        sed_inplace "s/  - \[ \] \*\*#$number\*\* /  - [x] **#$number** /" "$TODO_FILE"
        
        # Get task description for logging
        local task_description=$(grep "\*\*#$number\*\*" "$TODO_FILE" | head -1 | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//')
        
        # Log the action
        log_todo_action "COMPLETE" "$number" "$task_description"
        
        completed_count=$((completed_count + 1))
    done
    
    update_footer
    
    echo "Marked $completed_count task(s) as completed"
}

# Function to undo completion (reopen task)
undo_todo() {
    local number="$1"
    if [[ -z "$number" ]]; then
        echo "Error: Please provide todo number"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_number=$(resolve_task_reference "$number" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_number" ]]; then
        resolved_number="$number"
    fi
    number="$resolved_number"
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Use sed to directly find and replace the specific task (handle bold formatting and subtasks)
    sed_inplace "s/- \[x\] \*\*#$number\*\* /- [ ] **#$number** /" "$TODO_FILE"
    sed_inplace "s/  - \[x\] \*\*#$number\*\* /  - [ ] **#$number** /" "$TODO_FILE"
    update_footer
    
    # Get task description for logging
    local task_description=$(grep "\*\*#$number\*\*" "$TODO_FILE" | head -1 | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//')
    
    # Log the action
    log_todo_action "UNDO" "$number" "$task_description"
    
    echo "Reopened task $number"
}

# Function to modify a specific task
modify_todo() {
    local task_id="$1"
    local new_text="$2"
    local new_tags="$3"
    
    if [[ -z "$task_id" || -z "$new_text" ]]; then
        echo "Error: Please provide task ID and new text"
        echo "Usage: ./todo.ai modify <id> \"<new text>\" [\"<new tags>\"]"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Get the current completion status and existing line (handle both bold and non-bold formatting, and subtasks)
    # Check all possible indentations: main tasks (0 spaces), subtasks (2 spaces), sub-subtasks (4 spaces)
    local current_line=$(grep -E "^- \[.*\] (\*\*#$task_id\*\*|#$task_id) |^  - \[.*\] (\*\*#$task_id\*\*|#$task_id) |^    - \[.*\] (\*\*#$task_id\*\*|#$task_id) " "$TODO_FILE" | head -1)
    local current_status=$(echo "$current_line" | sed 's/- \[\([^]]*\)\].*/\1/' | sed 's/  - \[\([^]]*\)\].*/\1/' | sed 's/    - \[\([^]]*\)\].*/\1/')
    
    # Extract existing tags from current line (tags are in backticks after the task text)
    local existing_tags=""
    if echo "$current_line" | grep -q '\`#'; then
        # Extract tags (everything in backticks)
        existing_tags=$(echo "$current_line" | sed 's/.*\(`#[^`]*`\).*/\1/' | sed 's/`//g')
        # Handle multiple tags
        local all_tags=$(echo "$current_line" | grep -o '\`#[^`]*`' | sed 's/`//g' | tr '\n' ' ' | sed 's/ $//')
        if [[ -n "$all_tags" ]]; then
            existing_tags="$all_tags"
        fi
    fi
    
    # Determine nesting depth to apply correct indentation
    local task_depth=$(get_nesting_depth "$task_id")
    local indent=""
    
    # Format the new task line preserving completion status with bold task ID
    # Apply indentation based on nesting depth:
    # Depth 0 (main task): no indentation
    # Depth 1 (subtask like #2.5): 2 spaces
    # Depth 2 (sub-subtask like #2.5.4): 4 spaces
    if [[ $task_depth -eq 0 ]]; then
        indent=""
    elif [[ $task_depth -eq 1 ]]; then
        indent="  "
    elif [[ $task_depth -eq 2 ]]; then
        indent="    "
    else
        # Fallback to 2 spaces if depth is unexpected
        indent="  "
    fi
    
    local new_task_line="${indent}- [$current_status] **#$task_id** $new_text"
    
    # Use new_tags if provided, otherwise preserve existing tags
    local tags_to_use=""
    if [[ -n "$new_tags" ]]; then
        tags_to_use="$new_tags"
    elif [[ -n "$existing_tags" ]]; then
        tags_to_use="$existing_tags"
    fi
    
    if [[ -n "$tags_to_use" ]]; then
        # Wrap each tag in backticks for code styling
        local styled_tags=""
        # Split tags by space and process each one
        for tag in $(echo "$tags_to_use" | tr ' ' '\n'); do
            if [[ -n "$styled_tags" ]]; then
                styled_tags="$styled_tags \`$tag\`"
            else
                styled_tags="\`$tag\`"
            fi
        done
        new_task_line="$new_task_line $styled_tags"
    fi
    
    # Replace the task line using sed (handle bold formatting and subtasks)
    # The pattern needs to match the entire line including any existing tags (with backticks)
    # Escape special characters for sed replacement (using pipe as delimiter)
    local escaped_line=$(printf '%s\n' "$new_task_line" | sed 's/\\/\\\\/g' | sed 's/&/\\&/g' | sed 's/|/\\|/g')
    
    # Use pipe delimiter to avoid conflicts with / and other characters in replacement
    # Escape dots in task_id for sed pattern matching (dots are regex metacharacters)
    local escaped_task_id=$(echo "$task_id" | sed 's/\./\\./g')
    
    # Match everything after task ID including text and tags (with backticks)
    # Use task depth to determine which pattern to match (handles all indentation levels)
    if [[ $task_depth -eq 0 ]]; then
        # For main tasks, replace without indentation
        # Pattern matches: checkbox, task ID (with escaped dots), then everything (text and tags)
        sed_inplace "s|^- \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE"
    elif [[ $task_depth -eq 1 ]]; then
        # For subtasks, replace with proper 2-space indentation
        # Pattern matches: checkbox, task ID (with escaped dots), then everything (text and tags)
        sed_inplace "s|^  - \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE"
    elif [[ $task_depth -eq 2 ]]; then
        # For sub-subtasks, replace with proper 4-space indentation
        # Pattern matches: checkbox, task ID (with escaped dots), then everything (text and tags)
        sed_inplace "s|^    - \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE"
    else
        # Fallback: try all indentation levels
        sed_inplace "s|^    - \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE" || \
        sed_inplace "s|^  - \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE" || \
        sed_inplace "s|^- \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE"
    fi
    update_footer
    
    # Log the action
    log_todo_action "MODIFY" "$task_id" "$new_text"
    
    echo "Modified task #$task_id"
}

# Function to archive a completed task and its subtasks
archive_task() {
    local task_id=""
    local reason=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --reason)
                reason="$2"
                shift 2
                ;;
            *)
                task_id="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$task_id" ]]; then
        echo "Error: Please provide task ID"
        echo "Usage: ./todo.ai archive <id> [--reason <reason>]"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Determine task status and checkbox style
    local checkbox=""
    local status_note=""
    local is_completed=false
    
    # Check if task exists and its current state
    if grep -q "^- \[x\] \*\*#$task_id\*\* " "$TODO_FILE"; then
        # Task is completed
        is_completed=true
        checkbox="x"
    elif grep -q "^- \[ \] \*\*#$task_id\*\* " "$TODO_FILE"; then
        # Task is incomplete - need reason to archive
        if [[ -z "$reason" ]]; then
            echo "Error: Task #$task_id is not completed"
            echo "To archive incomplete tasks, provide --reason: obsolete, duplicate, wontfix, or completed-by:<tasks>"
            return 1
        fi
        # Set checkbox based on reason
        case "$reason" in
            obsolete)
                checkbox="~"
                status_note=" (obsolete)"
                ;;
            duplicate|duplicate:*)
                checkbox="~"
                status_note=" (duplicate)"
                ;;
            wontfix)
                checkbox="-"
                status_note=" (wontfix)"
                ;;
            completed-by:*)
                checkbox=">"
                status_note=" (${reason})"
                ;;
            *)
                checkbox="~"
                status_note=" (${reason})"
                ;;
        esac
    else
        echo "Error: Task #$task_id not found"
        return 1
    fi
    
    # Simple implementation: move the task to Recently Completed section
    # Get the task line (either completed or incomplete)
    # Escape task_id for grep pattern (escape dots and asterisks)
    local escaped_task_id=$(echo "$task_id" | sed 's/\./\\./g')
    local task_line=$(grep "^- \[[x ]\] \*\*#${escaped_task_id}\*\* " "$TODO_FILE")
    if [[ -z "$task_line" ]]; then
        echo "Error: Could not find task #$task_id"
        return 1
    fi
    
    # Update checkbox in task line if needed (for incomplete tasks with reason)
    if [[ "$checkbox" != "x" ]]; then
        # Replace checkbox: [ ] or [x] â†’ [$checkbox]
        task_line=$(echo "$task_line" | sed "s/\[.\]/[$checkbox]/")
    fi
    
    # Add completion date if not already present
    local archive_date=$(date +"%Y-%m-%d")
    if [[ ! "$task_line" =~ "\([0-9]{4}-[0-9]{2}-[0-9]{2}\)" ]]; then
        task_line="$task_line${status_note} ($archive_date)"
    fi
    
    # Collect all subtasks and nested subtasks (completed or not)
    local subtasks=()
    # Escape task_id for regex matching (escape dots)
    local escaped_task_id_regex=$(echo "$task_id" | sed 's/\./\\./g')
    while IFS= read -r line; do
        # Match subtasks at any nesting level: #task_id.1, #task_id.1.1, etc.
        # Use grep pattern instead of regex to avoid issues with asterisks
        if echo "$line" | grep -q "\*\*#${escaped_task_id_regex}\."; then
            # Add completion date if not already present
            if [[ ! "$line" =~ "\([0-9]{4}-[0-9]{2}-[0-9]{2}\)" ]]; then
                line="$line ($archive_date)"
            fi
            subtasks+=("$line")
        fi
    done < "$TODO_FILE"
    
    # Remove from Tasks section (main task and all subtasks at any nesting level)
    # Handle both completed [x] and incomplete [ ] tasks
    # Escape task_id for use in sed pattern
    local escaped_task_id=$(echo "$task_id" | sed 's/\./\\./g')
    sed_inplace "/^- \[[x ]\] \*\*#${escaped_task_id}\*\* /d" "$TODO_FILE"
    # Remove subtasks (2 spaces) and sub-subtasks (4 spaces)
    sed_inplace "/^  - \[.*\] \*\*#${escaped_task_id}\\./d" "$TODO_FILE"
    sed_inplace "/^    - \[.*\] \*\*#${escaped_task_id}\\./d" "$TODO_FILE"
    
    # Create a complete block with main task and subtasks
    local complete_block="$task_line"
    if [[ ${#subtasks[@]} -gt 0 ]]; then
        # Join subtasks with newlines
        local subtasks_text=$(printf '%s\n' "${subtasks[@]}")
        complete_block="$complete_block
$subtasks_text"
    fi
    
    # Add to Recently Completed section
    local recently_completed_section=$(grep -n "^## Recently Completed" "$TODO_FILE" | cut -d: -f1)
    if [[ -n "$recently_completed_section" ]]; then
        # Insert the complete block after the "## Recently Completed" line
        local temp_file=$(mktemp)
        echo -e "$complete_block" > "$temp_file"
        sed_inplace "${recently_completed_section}r $temp_file" "$TODO_FILE"
        rm -f "$temp_file"
    else
        # Add Recently Completed section if it doesn't exist
        echo "" >> "$TODO_FILE"
        echo "------------------" >> "$TODO_FILE"
        echo "" >> "$TODO_FILE"
        echo "## Recently Completed" >> "$TODO_FILE"
        echo -e "$complete_block" >> "$TODO_FILE"
    fi
    
    # Count subtasks for reporting
    local subtask_count=${#subtasks[@]}
    update_footer
    
    # Get task description for logging
    local task_description=$(echo "$task_line" | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//' | sed 's/ *([^)]*)$//')
    
    # Log the action
    log_todo_action "ARCHIVE" "$task_id" "$task_description (with $subtask_count subtasks)"
    
    echo "Archived task #$task_id and $subtask_count subtasks to Recently Completed section"
}

# Function to soft delete a task (move to Deleted section)
delete_task() {
    local with_subtasks=false
    local task_ids=()
    
    # Parse arguments (same pattern as complete)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --with-subtasks)
                with_subtasks=true
                shift
                ;;
            *)
                task_ids+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ ${#task_ids[@]} -eq 0 ]]; then
        echo "Error: Please provide at least one task number"
        return 1
    fi
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Auto-purge expired deleted tasks first
    purge_expired_deleted_tasks
    
    # Resolve task references and expand ranges
    local all_ids=()
    for id in "${task_ids[@]}"; do
        # Resolve task reference (auto-add prefix for number-only references)
        local resolved_id=$(resolve_task_reference "$id" 2>/dev/null)
        if [[ $? -ne 0 ]] || [[ -z "$resolved_id" ]]; then
            resolved_id="$id"
        fi
        
        if [[ "$resolved_id" =~ ^([0-9]+)\.([0-9]+)-([0-9]+)\.([0-9]+)$ ]] || [[ "$resolved_id" =~ ^[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)-[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)$ ]]; then
            local parent=${match[1]}
            local start=${match[2]}
            local end_parent=${match[3]}
            local end=${match[4]}
            if [[ "$parent" == "$end_parent" ]]; then
                for ((i=start; i<=end; i++)); do
                    all_ids+=("${parent}.${i}")
                done
            else
                all_ids+=("$id")
            fi
        elif [[ "$resolved_id" =~ ^([0-9]+)\.([0-9]+)-([0-9]+)$ ]] || [[ "$resolved_id" =~ ^[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)-([0-9]+)$ ]]; then
            local parent=${match[1]}
            local start=${match[2]}
            local end=${match[3]}
            # Get prefix if present
            local prefix=""
            if [[ "$resolved_id" =~ ^([a-z0-9]{1,7})- ]]; then
                prefix="${match[1]}-"
            fi
            for ((i=start; i<=end; i++)); do
                all_ids+=("${prefix}${parent}.${i}")
            done
        else
            all_ids+=("$resolved_id")
        fi
    done
    
    # Automatically include subtasks when deleting parent tasks (tasks without dots)
    # This prevents orphaned subtasks when a parent is deleted
        local expanded_ids=()
        for id in "${all_ids[@]}"; do
            expanded_ids+=("$id")
        # If this is a parent task (no dots), automatically find all subtasks
        # If --with-subtasks flag is used, also include subtasks for subtasks (but that's unusual)
        if [[ "$id" != *.* ]] || [[ "$with_subtasks" == "true" ]]; then
            # Find all direct subtasks and nested subtasks
            while IFS= read -r line; do
                # Extract task ID from line (handles nested IDs)
                if [[ "$line" =~ '#([0-9]+(\.[0-9]+)+)' ]]; then
                    local task_id="${match[1]}"
                    # Check if this task belongs to our parent (direct or nested subtask)
                    if [[ "$task_id" =~ ^$id\. ]]; then
                        expanded_ids+=("$task_id")
                    fi
                fi
            done < "$TODO_FILE"
        fi
        done
        all_ids=("${expanded_ids[@]}")
    
    # Delete all tasks
    local deleted_count=0
    local delete_date=$(date +"%Y-%m-%d")
    local expire_date=$(date -d "+30 days" +"%Y-%m-%d" 2>/dev/null || date -v+30d +"%Y-%m-%d" 2>/dev/null || echo "2025-11-29")
    
    for number in "${all_ids[@]}"; do
        # Find task (anywhere - Tasks or Recently Completed, handles nested subtasks)
        local task_line=$(grep "^- \[.\] \*\*#$number\*\* \|^  - \[.\] \*\*#$number\*\* \|^    - \[.\] \*\*#$number\*\* " "$TODO_FILE" | head -1)
        
        if [[ -z "$task_line" ]]; then
            echo "Warning: Task #$number not found, skipping"
            continue
        fi
        
        # Change checkbox to [D] and add deletion metadata
        task_line=$(echo "$task_line" | sed 's/\[.\]/[D]/')
        
        # Remove any existing date, then add deletion metadata
        task_line=$(echo "$task_line" | sed 's/ *([^)]*)$//')
        task_line="$task_line (deleted $delete_date, expires $expire_date)"
        
        # Find task line number to also remove following notes (handles nested subtasks at any level)
        local task_line_num=$(grep -n "^- \[.\] \*\*#$number\*\* \|^  - \[.\] \*\*#$number\*\* \|^    - \[.\] \*\*#$number\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
        
        if [[ -n "$task_line_num" ]]; then
            # Remove the task line
            sed_inplace "${task_line_num}d" "$TODO_FILE"
            
            # Remove any following blockquote notes (lines starting with "  > ", "    > ", or "      > ")
            # Keep removing lines as long as they're blockquotes
            while true; do
                local next_line=$(sed -n "${task_line_num}p" "$TODO_FILE")
                if [[ "$next_line" =~ ^"  > " ]] || [[ "$next_line" =~ ^"    > " ]] || [[ "$next_line" =~ ^"      > " ]]; then
                    sed_inplace "${task_line_num}d" "$TODO_FILE"
                else
                    break
                fi
            done
        fi
        
        # Add to Deleted section
        ensure_deleted_section
        local deleted_section=$(grep -n "^## Deleted Tasks" "$TODO_FILE" | cut -d: -f1)
        if [[ -n "$deleted_section" ]]; then
            if [[ "$(uname)" == "Darwin" ]]; then
                local temp_file=$(mktemp)
                head -n "$deleted_section" "$TODO_FILE" > "$temp_file"
                echo "$task_line" >> "$temp_file"
                tail -n +$((deleted_section + 1)) "$TODO_FILE" >> "$temp_file"
                mv "$temp_file" "$TODO_FILE"
            else
                sed_inplace "${deleted_section}a$task_line" "$TODO_FILE"
            fi
        fi
        
        # Log the action
        local task_description=$(echo "$task_line" | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//' | sed 's/ *(deleted.*//')
        log_todo_action "DELETE" "$number" "$task_description"
        
        deleted_count=$((deleted_count + 1))
    done
    
    update_footer
    
    echo "Moved $deleted_count task(s) to Deleted section"
}

# Function to ensure Deleted Tasks section exists
ensure_deleted_section() {
    if ! grep -q "^## Deleted Tasks" "$TODO_FILE"; then
        # Add Deleted section after Recently Completed
        local recently_completed_line=$(grep -n "^## Recently Completed" "$TODO_FILE" | cut -d: -f1)
        if [[ -n "$recently_completed_line" ]]; then
            # Find the end of the Recently Completed section (next section header or end of file)
            local next_section_line=$(awk "NR > $recently_completed_line && /^## / {print NR; exit}" "$TODO_FILE" || echo "")
            local insert_line
            if [[ -z "$next_section_line" ]]; then
                # No next section, insert at end of file
                insert_line=$(wc -l < "$TODO_FILE" | tr -d ' ')
            else
                # Insert before the next section
                insert_line=$((next_section_line - 1))
            fi
            
            if [[ "$(uname)" == "Darwin" ]]; then
                # Use temporary file approach for macOS compatibility
                local temp_file=$(mktemp)
                head -n "$insert_line" "$TODO_FILE" > "$temp_file"
                echo "" >> "$temp_file"
                echo "## Deleted Tasks" >> "$temp_file"
                echo "" >> "$temp_file"
                tail -n +$((insert_line + 1)) "$TODO_FILE" >> "$temp_file" 2>/dev/null || true
                mv "$temp_file" "$TODO_FILE"
            else
                # Insert after the last line before next section
                sed_inplace "${insert_line}a\\\n## Deleted Tasks\n" "$TODO_FILE"
            fi
        fi
    fi
}

# Function to purge expired deleted tasks
purge_expired_deleted_tasks() {
    local current_date=$(date +"%Y-%m-%d")
    local purged_count=0
    
    # Find and remove expired tasks
    while IFS= read -r line; do
        if [[ "$line" =~ "expires ([0-9]{4}-[0-9]{2}-[0-9]{2})" ]]; then
            local expire_date="${match[1]}"
            # Compare dates (simple string comparison works for YYYY-MM-DD format)
            if [[ "$expire_date" < "$current_date" ]]; then
                # Task expired, remove it
                sed_inplace "/$(echo "$line" | sed 's/[]\/$*.^[]/\\&/g')/d" "$TODO_FILE"
                purged_count=$((purged_count + 1))
            fi
        fi
    done < <(grep "^\- \[D\]" "$TODO_FILE")
    
    if [[ $purged_count -gt 0 ]]; then
        echo "Auto-purged $purged_count expired task(s)" >&2
    fi
}

# Function to restore a task and its subtasks from Recently Completed to Tasks
restore_task() {
    local task_id="$1"
    
    if [[ -z "$task_id" ]]; then
        echo "Error: Please provide task ID"
        echo "Usage: ./todo.ai restore <id>"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Simple implementation: move the task back to Tasks section
    # Get the task line (from Recently Completed or Deleted section)
    local task_line=$(grep "^- \[[xD~>\-]\] \*\*#$task_id\*\* " "$TODO_FILE" | head -1)
    if [[ -z "$task_line" ]]; then
        echo "Error: Could not find task #$task_id in Recently Completed or Deleted section"
        return 1
    fi
    
    # Restore to [ ] checkbox and remove metadata
    task_line=$(echo "$task_line" | sed 's/\[.\]/[ ]/')
    task_line=$(echo "$task_line" | sed 's/ *(deleted.*//' | sed 's/ *(completed.*//' | sed 's/ *(.*)$//')
    
    # Remove from current section (Recently Completed or Deleted)
    sed_inplace "/^- \[[xD~>\-]\] \*\*#$task_id\*\* /d" "$TODO_FILE"
    
    # Add to Tasks section
    local tasks_section=$(grep -n "^## Tasks" "$TODO_FILE" | cut -d: -f1)
    if [[ -n "$tasks_section" ]]; then
        # Insert after the "## Tasks" line
        if [[ "$(uname)" == "Darwin" ]]; then
            local temp_file=$(mktemp)
            head -n "$tasks_section" "$TODO_FILE" > "$temp_file"
            echo "$task_line" >> "$temp_file"
            tail -n +$((tasks_section + 1)) "$TODO_FILE" >> "$temp_file"
            mv "$temp_file" "$TODO_FILE"
        else
            sed_inplace "${tasks_section}a$task_line" "$TODO_FILE"
        fi
    else
        echo "Error: Tasks section not found"
        return 1
    fi
    
    update_footer
    
    # Get task description for logging
    local task_description=$(echo "$task_line" | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//' | sed 's/ *([^)]*)$//')
    
    # Log the action
    log_todo_action "RESTORE" "$task_id" "$task_description"
    
    echo "Restored task #$task_id to Tasks section"
}

# Function to ensure Task Metadata section exists
ensure_metadata_section() {
    if ! grep -q "^## Task Metadata" "$TODO_FILE"; then
        # Add metadata section at the end
        echo "" >> "$TODO_FILE"
        echo "## Task Metadata" >> "$TODO_FILE"
        echo "" >> "$TODO_FILE"
        echo "Task relationships and dependencies (managed by todo.ai tool)." >> "$TODO_FILE"
        echo "View with: \`./todo.ai show <task-id>\`" >> "$TODO_FILE"
        echo "" >> "$TODO_FILE"
        echo "<!-- TASK RELATIONSHIPS" >> "$TODO_FILE"
        echo "-->" >> "$TODO_FILE"
    fi
}

# Function to add a task relationship
add_relationship() {
    local task_id="$1"
    local rel_type="$2"
    local target_tasks="$3"
    
    # Ensure metadata section exists
    ensure_metadata_section
    
    # Remove any existing relationship of this type for this task
    sed_inplace "/^$task_id:$rel_type:/d" "$TODO_FILE"
    
    # Add new relationship before the closing -->
    sed_inplace "/^-->/i$task_id:$rel_type:$target_tasks" "$TODO_FILE"
    
    update_footer
}

# Function to remove a task relationship
remove_relationship() {
    local task_id="$1"
    local rel_type="$2"
    local target_task="$3"
    
    if [[ -n "$target_task" ]]; then
        # Remove specific target from relationship list
        # This is complex, for now just remove the whole relationship
        sed_inplace "/^$task_id:$rel_type:/d" "$TODO_FILE"
    else
        # Remove all relationships of this type for this task
        sed_inplace "/^$task_id:$rel_type:/d" "$TODO_FILE"
    fi
    
    update_footer
}

# Function to get relationships for a task
get_relationships() {
    local task_id="$1"
    
    # Extract relationships from metadata section
    sed -n '/<!-- TASK RELATIONSHIPS/,/-->/p' "$TODO_FILE" | \
        grep "^$task_id:" | \
        while IFS=: read -r id rel_type targets; do
            echo "$rel_type:$targets"
        done
}

# Function to show a task with its relationships
show_task() {
    local task_id="$1"
    
    if [[ -z "$task_id" ]]; then
        echo "Error: Please provide task ID"
        echo "Usage: ./todo.ai show <id>"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Find and display the task
    local task_line=$(grep "^- \[.\] \*\*#$task_id\*\* \|^  - \[.\] \*\*#$task_id\*\* " "$TODO_FILE" | head -1)
    
    if [[ -z "$task_line" ]]; then
        echo "Error: Task #$task_id not found"
        return 1
    fi
    
    echo "$task_line"
    
    # Get line number for note detection
    local task_line_num=$(grep -n "^- \[.\] \*\*#$task_id\*\* \|^  - \[.\] \*\*#$task_id\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
    
    # Display notes if they exist (blockquotes immediately after task)
    if [[ -n "$task_line_num" ]]; then
        local next_line_num=$((task_line_num + 1))
        local next_line=$(sed -n "${next_line_num}p" "$TODO_FILE")
        while [[ "$next_line" =~ ^"  > " ]] || [[ "$next_line" =~ ^"    > " ]]; do
            echo "$next_line"
            next_line_num=$((next_line_num + 1))
            next_line=$(sed -n "${next_line_num}p" "$TODO_FILE")
        done
    fi
    
    # Find and display subtasks if this is a parent
    if [[ "$task_id" != *.* ]]; then
        grep "^  - \[.\] \*\*#$task_id\." "$TODO_FILE" | while read -r subtask; do
            echo "$subtask"
        done
    fi
    
    # Display relationships if any exist
    local has_relationships=false
    while IFS=: read -r rel_type targets; do
        if [[ -n "$rel_type" ]]; then
            has_relationships=true
            # Format relationship type (replace - with space, capitalize)
            local formatted_type=""
            case "$rel_type" in
                completed-by) formatted_type="Completed by" ;;
                depends-on) formatted_type="Depends on" ;;
                blocks) formatted_type="Blocks" ;;
                related-to) formatted_type="Related to" ;;
                duplicate-of) formatted_type="Duplicate of" ;;
                *) formatted_type="$rel_type" ;;
            esac
            echo "  â†³ $formatted_type: $targets"
        fi
    done < <(get_relationships "$task_id")
    
    if [[ "$has_relationships" == false ]]; then
        echo "  (No relationships)"
    fi
}

# Function to manage task relationships
relate_task() {
    local task_id=""
    local rel_type=""
    local targets=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --completed-by)
                rel_type="completed-by"
                targets="$2"
                shift 2
                ;;
            --depends-on)
                rel_type="depends-on"
                targets="$2"
                shift 2
                ;;
            --blocks)
                rel_type="blocks"
                targets="$2"
                shift 2
                ;;
            --related-to)
                rel_type="related-to"
                targets="$2"
                shift 2
                ;;
            --duplicate-of)
                rel_type="duplicate-of"
                targets="$2"
                shift 2
                ;;
            *)
                task_id="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$task_id" ]] || [[ -z "$rel_type" ]] || [[ -z "$targets" ]]; then
        echo "Error: Missing required parameters"
        echo "Usage: ./todo.ai relate <id> --<relation-type> <target-ids>"
        echo ""
        echo "Relation types:"
        echo "  --completed-by <ids>   Task completed by other task(s)"
        echo "  --depends-on <ids>     Task depends on other task(s)"
        echo "  --blocks <ids>         Task blocks other task(s)"
        echo "  --related-to <ids>     General relationship"
        echo "  --duplicate-of <id>    Task is duplicate of another"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Verify task exists
    if ! grep -q "\*\*#$task_id\*\*" "$TODO_FILE"; then
        echo "Error: Task #$task_id not found"
        return 1
    fi
    
    # Add the relationship
    add_relationship "$task_id" "$rel_type" "$targets"
    
    # Log the action
    log_todo_action "RELATE" "$task_id" "$rel_type: $targets"
    
    echo "Added relationship: #$task_id $rel_type $targets"
}

# Function to add a note to a task (using blockquote format)
add_note() {
    local task_id="$1"
    local note_text="$2"
    
    if [[ -z "$task_id" ]] || [[ -z "$note_text" ]]; then
        echo "Error: Please provide task ID and note text"
        echo "Usage: ./todo.ai note <id> <note-text>"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Verify task exists
    local task_line_num=$(grep -n "^- \[.\] \*\*#$task_id\*\* \|^  - \[.\] \*\*#$task_id\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
    
    if [[ -z "$task_line_num" ]]; then
        echo "Error: Task #$task_id not found"
        return 1
    fi
    
    # Format note as blockquote with proper indentation
    local indent=""
    local task_line=$(sed -n "${task_line_num}p" "$TODO_FILE")
    if [[ "$task_line" =~ ^"  - " ]]; then
        # This is a subtask, needs extra indentation
        indent="  "
    fi
    
    # Create blockquote note
    local note_line="${indent}  > ${note_text}"
    
    # Insert note after the task line
    if [[ "$(uname)" == "Darwin" ]]; then
        local temp_file=$(mktemp)
        head -n "$task_line_num" "$TODO_FILE" > "$temp_file"
        echo "$note_line" >> "$temp_file"
        tail -n +$((task_line_num + 1)) "$TODO_FILE" >> "$temp_file"
        mv "$temp_file" "$TODO_FILE"
    else
        sed_inplace "${task_line_num}a\\$note_line" "$TODO_FILE"
    fi
    
    update_footer
    
    # Log the action
    log_todo_action "NOTE" "$task_id" "$note_text"
    
    echo "Added note to task #$task_id"
}

# Function to lint (identify) formatting issues
lint_todo() {
    local issues_found=0
    
    echo "ðŸ” Checking TODO.md for formatting issues..."
    echo ""
    
    # Check for indentation issues
    echo "ðŸ“‹ Checking indentation:"
    local indent_issues=0
    
    # Find subtasks that are not properly indented (should start with "  -")
    while IFS= read -r line; do
        if [[ "$line" =~ "^- \[.*\] \*\*#[0-9]+\.[0-9]+\*\* " ]]; then
            echo "  âŒ Subtask not indented: $line"
            indent_issues=$((indent_issues + 1))
            issues_found=$((issues_found + 1))
        fi
    done < "$TODO_FILE"
    
    if [[ $indent_issues -eq 0 ]]; then
        echo "  âœ… All subtasks properly indented"
    else
        echo "  ðŸ“Š Found $indent_issues indentation issues"
    fi
    echo ""
    
    # Check for malformed checkboxes
    echo "â˜‘ï¸  Checking checkboxes:"
    local checkbox_issues=0
    
    # Find malformed checkboxes
    while IFS= read -r line; do
        if [[ "$line" =~ "^- \[.*\] " || "$line" =~ "^  - \[.*\] " ]]; then
            # Check for various malformed checkbox patterns
            if [[ "$line" =~ "\[  \]" || "$line" =~ "\[   \]" || "$line" =~ "\[    \]" || "$line" =~ "\[\]" ]]; then
                echo "  âŒ Malformed checkbox: $line"
                checkbox_issues=$((checkbox_issues + 1))
                issues_found=$((issues_found + 1))
            fi
        fi
    done < "$TODO_FILE"
    
    if [[ $checkbox_issues -eq 0 ]]; then
        echo "  âœ… All checkboxes properly formatted"
    else
        echo "  ðŸ“Š Found $checkbox_issues checkbox issues"
    fi
    echo ""
    
    # Check for orphaned subtasks (subtasks without parent tasks)
    echo "ðŸ”— Checking for orphaned subtasks:"
    local orphan_issues=0
    local seen_parents=()
    
    # First pass: collect all parent task IDs
    while IFS= read -r line; do
        if [[ "$line" == "- ["*"**#"*"**"* ]] && [[ "$line" != *"**#"*"."*"**"* ]]; then
            local parent_id=$(echo "$line" | grep -o '#[0-9]\+' | sed 's/#//' | head -1)
            seen_parents+=("$parent_id")
        fi
    done < "$TODO_FILE"
    
    # Second pass: check all subtasks have parents
    while IFS= read -r line; do
        if [[ "$line" =~ '#([0-9]+)\.([0-9]+)' ]]; then
            local parent_id="${match[1]}"
            local subtask_id="${match[1]}.${match[2]}"
            if [[ ! " ${seen_parents[@]} " =~ " ${parent_id} " ]]; then
                echo "  âŒ Orphaned subtask #$subtask_id (parent #$parent_id not found)"
                orphan_issues=$((orphan_issues + 1))
                issues_found=$((issues_found + 1))
            fi
        fi
    done < <(grep "\*\*#[0-9]\+\.[0-9]\+\*\*" "$TODO_FILE")
    
    if [[ $orphan_issues -eq 0 ]]; then
        echo "  âœ… No orphaned subtasks"
    else
        echo "  ðŸ“Š Found $orphan_issues orphaned subtasks"
    fi
    echo ""
    
    # Check for duplicate task IDs
    echo "ðŸ”¢ Checking for duplicate task IDs:"
    local duplicate_issues=0
    local task_ids=()
    local duplicates=()
    
    while IFS= read -r line; do
        if [[ "$line" =~ '#([0-9]+\.[0-9]+|[0-9]+)' ]]; then
            local task_id="${match[1]}"
            if [[ " ${task_ids[@]} " =~ " ${task_id} " ]]; then
                if [[ ! " ${duplicates[@]} " =~ " ${task_id} " ]]; then
                    echo "  âŒ Duplicate task ID: #$task_id"
                    duplicates+=("$task_id")
                    duplicate_issues=$((duplicate_issues + 1))
                    issues_found=$((issues_found + 1))
                fi
            else
                task_ids+=("$task_id")
            fi
        fi
    done < <(grep "\*\*#[0-9]\|\*\*#[0-9]\+\.[0-9]\+" "$TODO_FILE")
    
    if [[ $duplicate_issues -eq 0 ]]; then
        echo "  âœ… No duplicate task IDs"
    else
        echo "  ðŸ“Š Found $duplicate_issues duplicate task IDs"
    fi
    echo ""
    
    # Check for empty lines in task sections
    echo "ðŸ“„ Checking for problematic empty lines:"
    local empty_line_issues=0
    local in_tasks=false
    local line_num=0
    
    while IFS= read -r line; do
        line_num=$((line_num + 1))
        if [[ "$line" == "## Tasks" ]] || [[ "$line" == "## Deleted Tasks" ]] || [[ "$line" == "## Recently Completed" ]]; then
            in_tasks=true
        elif [[ "$line" =~ ^"## " ]]; then
            in_tasks=false
        elif [[ $in_tasks == true ]] && [[ -z "$line" ]]; then
            # Check if previous and next lines are both tasks (not blockquotes or other content)
            local prev_line=$(sed -n "$((line_num-1))p" "$TODO_FILE")
            local next_line=$(sed -n "$((line_num+1))p" "$TODO_FILE")
            # Empty line between tasks is problematic
            if [[ "$prev_line" == "- ["*"**#"* ]] && [[ "$next_line" == "- ["*"**#"* ]]; then
                echo "  âš ï¸  Empty line between tasks at line $line_num"
                empty_line_issues=$((empty_line_issues + 1))
                issues_found=$((issues_found + 1))
            fi
        fi
    done < "$TODO_FILE"
    
    if [[ $empty_line_issues -eq 0 ]]; then
        echo "  âœ… No problematic empty lines"
    else
        echo "  ðŸ“Š Found $empty_line_issues empty line issues"
    fi
    echo ""
    
    # Summary
    if [[ $issues_found -eq 0 ]]; then
        echo "ðŸŽ‰ No formatting issues found! TODO.md is properly formatted."
    else
        echo "âš ï¸  Found $issues_found total formatting issues"
        echo "ðŸ’¡ Run './todo.ai --reformat --dry-run' to see what would be fixed"
        echo "ðŸ’¡ Run './todo.ai --reformat' to apply fixes"
    fi
}

# Function to detect and resolve task ID conflicts
resolve_conflicts() {
    local dry_run=false
    
    # Check for --dry-run flag
    if [[ "$1" == "--dry-run" ]]; then
        dry_run=true
        echo "ðŸ” DRY RUN: Showing what would be fixed..."
    else
        echo "ðŸ”§ Resolving task ID conflicts..."
    fi
    echo ""
    
    local conflicts_resolved=0
    
    # Step 1: Detect duplicate task IDs
    local task_ids=()
    local duplicates=()
    local duplicate_lines=()  # Store line numbers for duplicates
    
    local line_num=0
    while IFS= read -r line; do
        line_num=$((line_num + 1))
        # Match task IDs in format: **#task_id** or **#prefix-task_id**
        # Also match prefixed IDs like fxstein-50
        if [[ "$line" =~ '\*\*#([^ ]+)\*\*' ]]; then
            local task_id="${match[1]}"
            
            # Check if this task ID has been seen before
            local found_duplicate=false
            for existing_id in "${task_ids[@]}"; do
                if [[ "$existing_id" == "$task_id" ]]; then
                    found_duplicate=true
                    # Check if we already recorded this duplicate
                    local already_recorded=false
                    for dup_id in "${duplicates[@]}"; do
                        if [[ "$dup_id" == "$task_id" ]]; then
                            already_recorded=true
                            break
                        fi
                    done
                    if [[ "$already_recorded" == false ]]; then
                        duplicates+=("$task_id")
                    fi
                    duplicate_lines+=("$line_num|$task_id")
                    break
                fi
            done
            
            # Add to seen IDs
            if [[ "$found_duplicate" == false ]]; then
                task_ids+=("$task_id")
            fi
        fi
    done < "$TODO_FILE"
    
    if [[ ${#duplicates[@]} -eq 0 ]]; then
        echo "âœ… No duplicate task IDs found"
        return 0
    fi
    
    echo "ðŸ“Š Found ${#duplicates[@]} duplicate task ID(s):"
    for dup_id in "${duplicates[@]}"; do
        echo "  - #$dup_id"
    done
    echo ""
    
    # Step 2: Create mapping from old duplicate IDs to new IDs
    # Strategy: Keep first occurrence, renumber subsequent ones
    declare -A id_mapping  # old_id -> new_id
    local mode=$(get_numbering_mode)
    
    for dup_id in "${duplicates[@]}"; do
        # Find all occurrences of this duplicate
        local occurrences=()
        local first_line_num=""
        local occurrence_count=0
        
        line_num=0
        while IFS= read -r line; do
            line_num=$((line_num + 1))
            if [[ "$line" =~ '\*\*#'"$dup_id"'\*\*' ]]; then
                if [[ -z "$first_line_num" ]]; then
                    first_line_num="$line_num"
                else
                    # This is a duplicate - needs renumbering
                    occurrences+=("$line_num")
                fi
                occurrence_count=$((occurrence_count + 1))
            fi
        done < "$TODO_FILE"
        
        # Renumber each duplicate occurrence (except the first)
        local occurrence_index=1
        for dup_line_num in "${occurrences[@]}"; do
            # Generate new ID based on mode
            local new_id=""
            
            # Extract numeric part and prefix if any
            local numeric_part=""
            local prefix_part=""
            
            if [[ "$dup_id" =~ ^([a-z0-9]{1,7}-)?([0-9]+)(\.([0-9]+))?$ ]]; then
                prefix_part="${match[1]}"
                numeric_part="${match[2]}"
                if [[ -n "${match[4]}" ]]; then
                    # Subtask - preserve parent number, only renumber subtask part
                    local parent_num="$numeric_part"
                    local subtask_num="${match[4]}"
                    # Get next available subtask number for this parent
                    local next_subtask=$((subtask_num + occurrence_index))
                    new_id="${prefix_part}${parent_num}.${next_subtask}"
                else
                    # Main task - get next available number
                    # Find highest number in TODO.md for this prefix
                    local highest_num=0
                    for seen_id in "${task_ids[@]}"; do
                        if [[ "$seen_id" =~ ^${prefix_part}([0-9]+)(\.([0-9]+))?$ ]]; then
                            local seen_num="${match[1]}"
                            if [[ $seen_num -gt $highest_num ]]; then
                                highest_num=$seen_num
                            fi
                        fi
                    done
                    local next_num=$((highest_num + occurrence_index))
                    new_id="${prefix_part}${next_num}"
                fi
            else
                # Fallback: append occurrence index
                new_id="${dup_id}-dup${occurrence_index}"
            fi
            
            # Make sure new_id doesn't conflict with existing IDs
            local conflict=true
            local conflict_index=1
            while [[ "$conflict" == true ]]; do
                conflict=false
                for existing_id in "${task_ids[@]}"; do
                    if [[ "$existing_id" == "$new_id" ]]; then
                        conflict=true
                        # Adjust new_id
                        if [[ "$dup_id" =~ ^([a-z0-9]{1,7}-)?([0-9]+)(\.([0-9]+))?$ ]]; then
                            prefix_part="${match[1]}"
                            numeric_part="${match[2]}"
                            if [[ -n "${match[4]}" ]]; then
                                local parent_num="$numeric_part"
                                local subtask_num="${match[4]}"
                                local next_subtask=$((subtask_num + occurrence_index + conflict_index))
                                new_id="${prefix_part}${parent_num}.${next_subtask}"
                            else
                                local next_num=$((occurrence_index + conflict_index))
                                new_id="${prefix_part}${next_num}"
                            fi
                        else
                            new_id="${dup_id}-dup${occurrence_index}-${conflict_index}"
                        fi
                        conflict_index=$((conflict_index + 1))
                        break
                    fi
                done
            done
            
            # Add to mapping
            id_mapping["${dup_line_num}|${dup_id}"]="$new_id"
            occurrence_index=$((occurrence_index + 1))
        done
    done
    
    # Step 3: Apply renumbering
    if [[ "$dry_run" == true ]]; then
        echo "ðŸ“‹ Would renumber the following tasks:"
        for key in "${!id_mapping[@]}"; do
            IFS='|' read -r line_num old_id <<< "$key"
            local new_id="${id_mapping[$key]}"
            local task_line=$(sed -n "${line_num}p" "$TODO_FILE")
            echo "  Line $line_num: #$old_id â†’ #$new_id"
            echo "    $task_line"
        done
        echo ""
        echo "ðŸ’¡ Run './todo.ai resolve-conflicts' to apply these changes"
    else
        # Create backup before making changes
        local backup_name=$(create_mode_backup 2>/dev/null || echo "")
        
        # Apply changes by reading file and replacing IDs
        local temp_file=$(mktemp)
        local line_num=0
        
        while IFS= read -r line; do
            line_num=$((line_num + 1))
            local new_line="$line"
            local line_changed=false
            
            # Check if this line needs renumbering
            for key in "${!id_mapping[@]}"; do
                IFS='|' read -r dup_line_num old_id <<< "$key"
                if [[ "$line_num" == "$dup_line_num" ]]; then
                    local new_id="${id_mapping[$key]}"
                    # Replace task ID in line
                    new_line=$(echo "$new_line" | sed "s/\\*\\*#${old_id}\\*\\*/\\*\\*#${new_id}\\*\\*/g")
                    line_changed=true
                    conflicts_resolved=$((conflicts_resolved + 1))
                    echo "  âœ… Renumbered: Line $line_num: #$old_id â†’ #$new_id"
                    break
                fi
            done
            
            # Also update references to old IDs in relationships, notes, etc.
            if [[ "$line_changed" == false ]]; then
                for key in "${!id_mapping[@]}"; do
                    IFS='|' read -r dup_line_num old_id <<< "$key"
                    local new_id="${id_mapping[$key]}"
                    # Replace references (e.g., in relationships: #old_id or old_id:)
                    if [[ "$new_line" =~ "#${old_id}" ]] || [[ "$new_line" =~ ":${old_id}" ]] || [[ "$new_line" =~ "${old_id}:" ]]; then
                        new_line=$(echo "$new_line" | sed "s/#${old_id}\\([^0-9a-z-]\\|$\\)/#${new_id}\\1/g")
                        new_line=$(echo "$new_line" | sed "s/:${old_id}\\([^0-9a-z-]\\|$\\)/:${new_id}\\1/g")
                        new_line=$(echo "$new_line" | sed "s/${old_id}:\\([^0-9a-z-]\\|$\\)/${new_id}:\\1/g")
                    fi
                done
            fi
            
            echo "$new_line" >> "$temp_file"
        done < "$TODO_FILE"
        
        # Replace original file
        mv "$temp_file" "$TODO_FILE"
        
        update_footer
        
        # Log the action
        log_todo_action "RESOLVE_CONFLICTS" "${#duplicates[@]}" "Resolved ${#duplicates[@]} duplicate task ID(s)"
        
        if [[ -n "$backup_name" ]]; then
            echo ""
            echo "ðŸ’¾ Backup created: $backup_name"
        fi
    fi
    
    echo ""
    if [[ "$dry_run" == true ]]; then
        echo "ðŸ’¡ Run './todo.ai resolve-conflicts' to apply these changes"
    elif [[ $conflicts_resolved -gt 0 ]]; then
        echo "âœ… Resolved $conflicts_resolved conflict(s)"
    else
        echo "âœ… No conflicts found"
    fi
}

# Function to reformat (fix) formatting issues
reformat_todo() {
    local dry_run=false
    
    # Check for --dry-run flag
    if [[ "$1" == "--dry-run" ]]; then
        dry_run=true
        echo "ðŸ” DRY RUN: Showing what would be fixed..."
    else
        echo "ðŸ”§ Applying formatting fixes..."
    fi
    echo ""
    
    local fixes_applied=0
    
    # Fix indentation issues
    echo "ðŸ“‹ Fixing indentation:"
    local indent_fixes=0
    
    # Find subtasks that are not properly indented
    while IFS= read -r line; do
        if [[ "$line" =~ "^- \[.*\] \*\*#[0-9]+\.[0-9]+\*\* " ]]; then
            local fixed_line="  $line"
            if [[ "$dry_run" == true ]]; then
                echo "  ðŸ”„ Would fix: $line"
                echo "  âž¡ï¸  To:        $fixed_line"
            else
                sed_inplace "s|^$line|$fixed_line|" "$TODO_FILE"
                echo "  âœ… Fixed: $line"
            fi
            indent_fixes=$((indent_fixes + 1))
            fixes_applied=$((fixes_applied + 1))
        fi
    done < "$TODO_FILE"
    
    if [[ $indent_fixes -eq 0 ]]; then
        echo "  âœ… No indentation issues found"
    else
        if [[ "$dry_run" == true ]]; then
            echo "  ðŸ“Š Would fix $indent_fixes indentation issues"
        else
            echo "  ðŸ“Š Fixed $indent_fixes indentation issues"
        fi
    fi
    echo ""
    
    # Fix checkbox issues
    echo "â˜‘ï¸  Fixing checkboxes:"
    local checkbox_fixes=0
    
    # Check if there are malformed checkboxes
    if grep -q "\[  \]\|\[   \]\|\[    \]\|\[\]" "$TODO_FILE"; then
        if [[ "$dry_run" == true ]]; then
            echo "  ðŸ”„ Would fix malformed checkboxes:"
            grep -n "\[  \]\|\[   \]\|\[    \]\|\[\]" "$TODO_FILE" | while read -r line; do
                echo "    Line: $line"
            done
        else
            # Use the existing normalize_checkboxes function directly
            normalize_checkboxes
            echo "  âœ… Fixed malformed checkboxes"
        fi
        checkbox_fixes=$((checkbox_fixes + 1))
        fixes_applied=$((fixes_applied + 1))
    fi
    
    if [[ $checkbox_fixes -eq 0 ]]; then
        echo "  âœ… No checkbox issues found"
    else
        if [[ "$dry_run" == true ]]; then
            echo "  ðŸ“Š Would fix $checkbox_fixes checkbox patterns"
        else
            echo "  ðŸ“Š Fixed $checkbox_fixes checkbox patterns"
        fi
    fi
    echo ""
    
    # Summary
    if [[ "$dry_run" == true ]]; then
        echo "ðŸ’¡ Run './todo.ai --reformat' to apply these fixes"
    elif [[ $fixes_applied -gt 0 ]]; then
        echo "ðŸŽ‰ Applied $fixes_applied formatting fixes to TODO.md"
    else
        echo "ðŸŽ‰ No formatting issues found - TODO.md is already properly formatted!"
    fi
}

# Function to edit todo file
edit_todo() {
    ${EDITOR:-nano} "$TODO_FILE"
}

# Function to view TODO log
view_log() {
    local filter="$1"
    local lines="$2"
    
    if [[ ! -f "$LOG_FILE" ]]; then
        echo "No log file found at $LOG_FILE"
        return 1
    fi
    
    echo "ðŸ“‹ TODO Tool Log"
    echo "================="
    echo ""
    
    if [[ -n "$filter" ]]; then
        echo "Filtering by: $filter"
        echo ""
        grep -i "$filter" "$LOG_FILE" | head -n "${lines:-50}"
    else
        head -n "${lines:-50}" "$LOG_FILE"
    fi
}

# Function to check for updates (informational only)
check_version() {
    if ! command -v curl >/dev/null 2>&1; then
        return 0
    fi
    
    # Try to get version from remote script
    local remote_version=$(curl -s "$SCRIPT_URL" | grep -i "^# Version:" | head -1 | sed 's/.*Version:[ ]*\([0-9.]*\).*/\1/' || echo "")
    
    if [[ -z "$remote_version" ]]; then
        # Try alternative extraction method
        remote_version=$(curl -s "$SCRIPT_URL" | grep -i "VERSION=" | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "")
    fi
    
    if [[ -n "$remote_version" && "$remote_version" != "$VERSION" ]]; then
        echo ""
        echo "ðŸ’¡ Update available: $VERSION â†’ $remote_version"
        echo "   Run './todo.ai update' to update to latest version"
        return 1
    fi
    
    return 0
}

# Function to ensure backups directory exists
init_backups_dir() {
    local backups_dir="$(pwd)/.todo.ai/backups"
    if [[ ! -d "$backups_dir" ]]; then
        mkdir -p "$backups_dir" 2>/dev/null || return 1
    fi
    echo "$backups_dir"
}

# Function to get script path
get_script_path() {
    local script_path
    
    # Strategy 1: Try zsh-specific absolute path (works when script is executed directly)
    if [[ -f "${0:a}" ]] && [[ "${0:a}" =~ ^/ ]]; then
        script_path="${0:a}"
    # Strategy 2: If script is executed via PATH, use command -v/which to find it
    elif command -v todo.ai >/dev/null 2>&1; then
        # Get the actual path from PATH
        script_path=$(command -v todo.ai 2>/dev/null || which todo.ai 2>/dev/null || echo "")
        # Verify it exists and is readable
        if [[ -z "$script_path" ]] || [[ ! -f "$script_path" ]]; then
            script_path=""
        fi
    # Strategy 3: Try current directory
    elif [[ -f "$(pwd)/todo.ai" ]]; then
        script_path="$(pwd)/todo.ai"
    # Strategy 4: Try relative path
    elif [[ -f "./todo.ai" ]]; then
        script_path="./todo.ai"
    else
        return 1
    fi
    
    # Ensure we found a valid path
    if [[ -z "$script_path" ]] || [[ ! -f "$script_path" ]]; then
        return 1
    fi
    
    # Ensure absolute path
    if [[ ! "$script_path" =~ ^/ ]]; then
        script_path="$(cd "$(dirname "$script_path")" 2>/dev/null && pwd)/$(basename "$script_path")"
        # If cd failed, try realpath if available
        if [[ ! "$script_path" =~ ^/ ]] && command -v realpath >/dev/null 2>&1; then
            script_path=$(realpath "$script_path" 2>/dev/null || echo "$script_path")
        fi
    fi
    
    # Final verification
    if [[ -z "$script_path" ]] || [[ ! -f "$script_path" ]] || [[ ! "$script_path" =~ ^/ ]]; then
        return 1
    fi
    
    echo "$script_path"
}

# Function to get todo.ai path for cursor rules (handles different installation scenarios)
get_todo_ai_path_for_rules() {
    # Check if we're in the developer repo (todo.ai repository itself)
    local is_dev_repo=false
    if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
        local remote_url=$(git remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            # Check if this is the todo.ai repository
            # zsh regex: match array is stored in $match
            if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
                local repo_owner="${match[1]}"
                local repo_name="${match[2]%.git}"
                # Check if this is the fxstein/todo.ai repository
                if [[ "$repo_name" == "todo.ai" ]] && [[ "$repo_owner" == "fxstein" ]]; then
                    is_dev_repo=true
                fi
            fi
        fi
    fi
    
    # If in developer repo, use relative path (current behavior)
    if [[ "$is_dev_repo" == true ]]; then
        echo "./todo.ai"
        return 0
    fi
    
    # Strategy 1: Check if tool is in PATH (works for global installs)
    if command -v todo.ai >/dev/null 2>&1; then
        local path_location=$(which todo.ai 2>/dev/null || command -v todo.ai 2>/dev/null)
        if [[ -n "$path_location" ]]; then
            # If in a standard bin directory, just use command name (no path needed)
            if [[ "$path_location" == *"/bin/todo.ai" ]] || [[ "$path_location" == *"/usr/local/bin/todo.ai" ]] || [[ "$path_location" == *"/usr/bin/todo.ai" ]]; then
                echo "todo.ai"
                return 0
            fi
        fi
    fi
    
    # Strategy 2: Check if script is in current directory (project-specific install)
    local current_dir="$(pwd)"
    if [[ -f "${current_dir}/todo.ai" ]]; then
        echo "./todo.ai"
        return 0
    fi
    
    # Strategy 3: Use script's own location (most reliable fallback)
    local script_path
    script_path=$(get_script_path) || {
        # Fallback: try to detect from $0
        if [[ -f "${0:a}" ]]; then
            script_path="${0:a}"
        else
            echo "./todo.ai"  # Final fallback
            return 0
        fi
    }
    
    # Convert absolute path to relative if possible
    if [[ "$script_path" =~ ^"${current_dir}"/(.+) ]]; then
        # Script is within current directory - use relative path
        echo "./${match[1]}"
    elif [[ "$script_path" =~ ^"${HOME}"/(.+) ]]; then
        # Script is in home directory - use ~/path
        echo "~/${match[1]}"
    else
        # Use absolute path as last resort
        echo "$script_path"
    fi
}

# Function to list available backups
list_backups() {
    local backups_dir
    backups_dir=$(init_backups_dir) || {
        echo "Error: Cannot access backups directory"
        return 1
    }
    
    # Check if any backups exist using find to avoid glob expansion issues
    local backup_files=$(find "$backups_dir" -maxdepth 1 -name "todo.ai.*" -type f 2>/dev/null)
    if [[ -z "$backup_files" ]]; then
        echo "No backups available"
        return 0
    fi
    
    echo "Available backups:"
    echo ""
    
    # Sort by modification time (newest first)
    local sorted_backups=($(echo "$backup_files" | xargs ls -t 2>/dev/null))
    
    local index=1
    for backup in "${sorted_backups[@]}"; do
        local filename=$(basename "$backup")
        local timestamp=$(echo "$filename" | sed 's/todo\.ai\.//')
        local version=$(grep -i "VERSION=" "$backup" 2>/dev/null | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "unknown")
        local date_str=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$backup" 2>/dev/null || stat -c "%y" "$backup" 2>/dev/null | cut -d'.' -f1 || echo "unknown")
        
        if [[ $index -eq 1 ]]; then
            echo "  [$index] $timestamp (v$version) - $date_str [LATEST]"
        else
            echo "  [$index] $timestamp (v$version) - $date_str"
        fi
        ((index++))
    done
    echo ""
    echo "Use './todo.ai rollback [index|timestamp]' to restore a backup"
}

# Function to rollback to a previous version
rollback() {
    local backups_dir
    backups_dir=$(init_backups_dir) || {
        echo "Error: Cannot access backups directory"
        return 1
    }
    
    local script_path
    script_path=$(get_script_path) || {
        echo "Error: Cannot locate todo.ai script"
        return 1
    }
    
    local backup_files=$(find "$backups_dir" -maxdepth 1 -name "todo.ai.*" -type f 2>/dev/null)
    if [[ -z "$backup_files" ]]; then
        echo "Error: No backups available"
        return 1
    fi
    
    local sorted_backups=($(echo "$backup_files" | xargs ls -t 2>/dev/null))
    
    local target_backup=""
    
    if [[ $# -eq 0 ]]; then
        # Default: rollback to latest backup
        target_backup="${sorted_backups[1]}"
    elif [[ "$1" =~ ^[0-9]+$ ]]; then
        # Index specified
        local index=$1
        if [[ $index -ge 1 ]] && [[ $index -le ${#sorted_backups[@]} ]]; then
            target_backup="${sorted_backups[$index]}"
        else
            echo "Error: Invalid backup index. Use './todo.ai backups' to see available backups"
            return 1
        fi
    else
        # Timestamp or version specified
        local search_term="$1"
        for backup in "${sorted_backups[@]}"; do
            local filename=$(basename "$backup")
            local timestamp=$(echo "$filename" | sed 's/todo\.ai\.//')
            local version=$(grep -i "VERSION=" "$backup" 2>/dev/null | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "")
            
            if [[ "$timestamp" == "$search_term" ]] || [[ "$version" == "$search_term" ]]; then
                target_backup="$backup"
                break
            fi
        done
        
        if [[ -z "$target_backup" ]]; then
            echo "Error: No backup found matching '$search_term'"
            echo "Use './todo.ai backups' to see available backups"
            return 1
        fi
    fi
    
    if [[ ! -f "$target_backup" ]]; then
        echo "Error: Backup file not found"
        return 1
    fi
    
    # Confirm rollback
    local backup_version=$(grep -i "VERSION=" "$target_backup" 2>/dev/null | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "unknown")
    local current_version="$VERSION"
    local backup_name=$(basename "$target_backup")
    
    echo "âš ï¸  Rollback Warning:"
    echo "   Current version: $current_version"
    echo "   Backup version:  $backup_version"
    echo "   Backup file:     $backup_name"
    echo ""
    echo "This will replace the current script with the backup version."
    echo "Continue? (y/N)"
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "Rollback cancelled"
        return 0
    fi
    
    # Create a backup of current version before rollback
    local timestamp=$(date +"%Y%m%d%H%M%S")
    cp "$script_path" "$backups_dir/todo.ai.$timestamp" 2>/dev/null || true
    
    # Restore from backup
    cp "$target_backup" "$script_path" || {
        echo "Error: Failed to restore backup"
        return 1
    }
    
    chmod +x "$script_path"
    
    echo "âœ… Rolled back to version $backup_version"
    echo "   Current version backed up as: todo.ai.$timestamp"
}

# Function to update todo.ai to latest version
update_tool() {
    # Get the actual script path
    local script_path
    script_path=$(get_script_path) || {
        echo "Error: Cannot locate todo.ai script"
        return 1
    }
    
    local backups_dir
    backups_dir=$(init_backups_dir) || {
        echo "Error: Cannot create backups directory"
        return 1
    }
    
    echo "ðŸ”„ Updating todo.ai..."
    
    if ! command -v curl >/dev/null 2>&1; then
        echo "Error: curl is required to update todo.ai"
        echo "Please download manually from: $REPO_URL"
        return 1
    fi
    
    # Check if already at latest version
    local remote_version=$(curl -s "$SCRIPT_URL" | grep -i "VERSION=" | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "")
    
    # If version matches, check content hash to detect changes even with same version
    if [[ -n "$remote_version" ]] && [[ "$remote_version" == "$VERSION" ]]; then
        local local_hash=""
        local remote_hash=""
        
        # Download remote file temporarily to compute hash
        local temp_check_file=$(mktemp)
        if curl -s -o "$temp_check_file" "$SCRIPT_URL" && [[ -s "$temp_check_file" ]] && grep -q "todo - AI-Agent First TODO List Tracker" "$temp_check_file"; then
            # Verify we're not comparing the same file
            local script_realpath=$(realpath "$script_path" 2>/dev/null || echo "$script_path")
            local temp_realpath=$(realpath "$temp_check_file" 2>/dev/null || echo "$temp_check_file")
            
            # If somehow they're the same file, skip hash comparison and proceed with update
            if [[ "$script_realpath" == "$temp_realpath" ]] || [[ ! -f "$script_path" ]]; then
                rm -f "$temp_check_file"
                echo "âš ï¸  Cannot compare hashes - proceeding with update to be safe"
            else
                # Compute local file hash (prefer sha256sum, fallback to md5 or shasum)
                if command -v sha256sum >/dev/null 2>&1; then
                    local_hash=$(sha256sum "$script_path" 2>/dev/null | cut -d' ' -f1)
                    remote_hash=$(sha256sum "$temp_check_file" 2>/dev/null | cut -d' ' -f1)
                elif command -v shasum >/dev/null 2>&1; then
                    local_hash=$(shasum -a 256 "$script_path" 2>/dev/null | cut -d' ' -f1)
                    remote_hash=$(shasum -a 256 "$temp_check_file" 2>/dev/null | cut -d' ' -f1)
                elif command -v md5sum >/dev/null 2>&1; then
                    local_hash=$(md5sum "$script_path" 2>/dev/null | cut -d' ' -f1)
                    remote_hash=$(md5sum "$temp_check_file" 2>/dev/null | cut -d' ' -f1)
                elif command -v md5 >/dev/null 2>&1; then
                    local_hash=$(md5 -q "$script_path" 2>/dev/null)
                    remote_hash=$(md5 -q "$temp_check_file" 2>/dev/null)
                fi
                
                rm -f "$temp_check_file"
                
                # If hashes couldn't be computed, proceed with update to be safe
                if [[ -z "$local_hash" ]] || [[ -z "$remote_hash" ]]; then
                    echo "âš ï¸  Could not compute hashes - proceeding with update to be safe"
                fi
            fi
            
            # If hashes are available and match, files are identical - skip update
            # But only if we verified the files are different (checked above)
            if [[ "$script_realpath" != "$temp_realpath" ]] && [[ -n "$local_hash" ]] && [[ -n "$remote_hash" ]] && [[ "$local_hash" == "$remote_hash" ]]; then
                echo "âœ… todo.ai is already at the latest version ($VERSION)"
                echo "   Content hash matches - no update needed"
                echo "   Checking cursor rules..."
                # Still update cursor rules even if script is up to date
                if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
                    echo ""
                    echo "ðŸ”„ Updating cursor rules..."
                    # Call init_cursor_rules directly since we're in the same script
                    init_cursor_rules
                fi
                return 0
            elif [[ "$script_realpath" != "$temp_realpath" ]] && [[ -n "$local_hash" ]] && [[ -n "$remote_hash" ]] && [[ "$local_hash" != "$remote_hash" ]]; then
                # Version matches but content differs - proceed with update
                echo "âš ï¸  Version matches ($VERSION), but content differs"
                echo "   Updating to latest content..."
            else
                # Hash comparison not available or files are same - proceed with update to be safe
                if [[ "$script_realpath" == "$temp_realpath" ]]; then
                    echo "âš ï¸  Cannot verify update - files appear identical"
                    echo "   Proceeding with update to ensure latest version..."
                elif [[ -z "$local_hash" ]] || [[ -z "$remote_hash" ]]; then
                    echo "âš ï¸  Hash comparison not available - proceeding with update"
                    echo "   Content may have changed even though version matches"
                else
                    echo "âš ï¸  Proceeding with update to ensure latest version"
                fi
            fi
        else
            rm -f "$temp_check_file"
            # Download failed - assume up to date if version matches
            echo "âœ… todo.ai is already at the latest version ($VERSION)"
            echo "   Checking cursor rules..."
            if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
                echo ""
                echo "ðŸ”„ Updating cursor rules..."
                init_cursor_rules
            fi
            return 0
        fi
    fi
    
    # Download latest version
    local temp_file=$(mktemp)
    if curl -s -o "$temp_file" "$SCRIPT_URL"; then
        # Check if download was successful
        if [[ -s "$temp_file" ]] && grep -q "todo - AI-Agent First TODO List Tracker" "$temp_file"; then
            # Create versioned backup with timestamp
            local timestamp=$(date +"%Y%m%d%H%M%S")
            local current_version="$VERSION"
            local backup_file="$backups_dir/todo.ai.$timestamp"
            
            # Backup current version
            cp "$script_path" "$backup_file" 2>/dev/null || {
                echo "Warning: Failed to create backup, continuing with update..."
            }
            
            # Get new version before replacing
            local new_version=$(grep -i "VERSION=" "$temp_file" | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "unknown")
            
            # Make new version executable
            chmod +x "$temp_file"
            
            # CRITICAL FIX: Execute new version's code BEFORE replacing old version
            # This ensures new version's update logic, migrations, and cursor rules updates run
            echo ""
            echo "ðŸ”„ Executing new version's update logic (v$new_version)..."
            local current_dir=$(pwd)
            local script_dir=$(dirname "$script_path")
            cd "$script_dir" 2>/dev/null || true
            
            # Execute new version's script directly (not via PATH or current directory)
            # This ensures the new script's code executes, not the old version
            # 1. Migrations (runs automatically at startup via run_migrations)
            # 2. Cursor rules update (runs automatically at startup via init_cursor_rules)
            # The new version's code will execute with its own logic, not the old version's
            # Suppress stdout (version info) but allow stderr (migration/cursor rules messages) through
            /bin/zsh "$temp_file" version >/dev/null || true
            
            # Now replace the old version with the new version
            mv "$temp_file" "$script_path"
            
            cd "$current_dir" 2>/dev/null || true
            
            echo "âœ… Updated todo.ai to version $new_version"
            if [[ -f "$backup_file" ]]; then
                echo "   Backup saved as: $(basename "$backup_file") (v$current_version)"
                echo "   Use './todo.ai rollback' to restore previous version"
            fi
            
            return 0
        else
            echo "Error: Downloaded file appears invalid"
            rm -f "$temp_file"
            return 1
        fi
    else
        echo "Error: Failed to download latest version"
        echo "Please check your internet connection or download manually from: $REPO_URL"
        rm -f "$temp_file"
        return 1
    fi
}




# ============================================================================
# Migration System
# ============================================================================

# Migration registry
# Format: "VERSION|MIGRATION_ID|DESCRIPTION|FUNCTION_NAME"
declare -a MIGRATIONS=(
    "1.3.5|section_order_fix|Fix TODO.md section order|migrate_section_order"
    "1.6.0|cursor_rules_to_mdc|Convert .cursorrules to .cursor/rules/ directory structure|migrate_cursor_rules_to_mdc"
)

# Function to compare semantic versions
version_compare() {
    local version1="$1"
    local version2="$2"
    local operator="$3"
    
    # Convert versions to comparable format (1.3.5 -> 1003005)
    local v1_num=$(echo "$version1" | awk -F. '{printf "%d%03d%03d", $1, $2, $3}')
    local v2_num=$(echo "$version2" | awk -F. '{printf "%d%03d%03d", $1, $2, $3}')
    
    case "$operator" in
        ">=") [[ $v1_num -ge $v2_num ]] ;;
        ">")  [[ $v1_num -gt $v2_num ]] ;;
        "<=") [[ $v1_num -le $v2_num ]] ;;
        "<")  [[ $v1_num -lt $v2_num ]] ;;
        "==") [[ $v1_num -eq $v2_num ]] ;;
        *) return 1 ;;
    esac
}

# Function to run migrations
run_migrations() {
    local current_version="$VERSION"
    local migrations_dir="$(pwd)/.todo.ai/migrations"
    local lock_file="${migrations_dir}/.migrations_lock"
    
    # Lock to prevent concurrent execution
    if [[ -f "$lock_file" ]]; then
        # Another instance is running migrations, skip
        return 0
    fi
    
    # Create migrations directory if it doesn't exist
    mkdir -p "$migrations_dir" 2>/dev/null || return 1
    
    # Create lock file
    touch "$lock_file" 2>/dev/null || return 1
    
    # Find the highest already-executed migration version to determine "from" version
    local last_migrated_version=""
    if [[ -d "$migrations_dir" ]]; then
        # Find highest version from migration marker files
        for migration_file in "$migrations_dir"/v*_*.migrated; do
            if [[ -f "$migration_file" ]]; then
                local filename=$(basename "$migration_file")
                # Extract version (e.g., v1.3.5_section_order_fix.migrated -> 1.3.5)
                # Use sed for reliable extraction across shell versions
                local file_version=$(echo "$filename" | sed -n 's/^v\([0-9]\+\.[0-9]\+\.[0-9]\+\)_.*/\1/p')
                if [[ -n "$file_version" ]]; then
                    # Keep track of highest version
                    if [[ -z "$last_migrated_version" ]]; then
                        last_migrated_version="$file_version"
                    elif version_compare "$file_version" "$last_migrated_version" ">"; then
                        last_migrated_version="$file_version"
                    fi
                fi
            fi
        done
    fi
    
    # Collect pending migrations
    local pending_migrations=()
    local highest_pending_version=""
    for migration in "${MIGRATIONS[@]}"; do
        IFS='|' read -r target_version migration_id description function_name <<< "$migration"
        
        # Check if this migration applies to current or earlier version
        if version_compare "$current_version" "$target_version" ">="; then
            # Check if already executed
            local migration_file="${migrations_dir}/v${target_version}_${migration_id}.migrated"
            if [[ ! -f "$migration_file" ]]; then
                pending_migrations+=("$target_version|$migration_id|$description|$function_name")
                # Track highest pending migration version
                if [[ -z "$highest_pending_version" ]]; then
                    highest_pending_version="$target_version"
                elif version_compare "$target_version" "$highest_pending_version" ">"; then
                    highest_pending_version="$target_version"
                fi
            fi
        fi
    done
    
    # Display migration info if there are pending migrations
    if [[ ${#pending_migrations[@]} -gt 0 ]]; then
        # Determine from version: use last migrated version, or assume it's lower than first pending
        local from_version="$last_migrated_version"
        if [[ -z "$from_version" ]]; then
            # No migrations executed yet - find lowest pending version
            local lowest_pending_version=""
            for migration_data in "${pending_migrations[@]}"; do
                IFS='|' read -r target_version migration_id description function_name <<< "$migration_data"
                if [[ -z "$lowest_pending_version" ]]; then
                    lowest_pending_version="$target_version"
                elif version_compare "$target_version" "$lowest_pending_version" "<"; then
                    lowest_pending_version="$target_version"
                fi
            done
            # Estimate previous version (one patch version before lowest pending)
            # This is an approximation - actual previous version might be lower
            from_version="$lowest_pending_version"
        fi
        
        # Determine to version: use current version, or highest pending if higher
        local to_version="$current_version"
        if [[ -n "$highest_pending_version" ]] && version_compare "$highest_pending_version" "$current_version" ">"; then
            # This shouldn't happen in normal cases, but handle it
            to_version="$highest_pending_version"
        fi
        
        # Display migration info
        echo "ðŸ”„ Running migrations: $from_version â†’ $to_version" >&2
    fi
    
    # Process each migration
    for migration in "${MIGRATIONS[@]}"; do
        IFS='|' read -r target_version migration_id description function_name <<< "$migration"
        
        # Check if this migration applies to current or earlier version
        if version_compare "$current_version" "$target_version" ">="; then
            # Check if already executed
            local migration_file="${migrations_dir}/v${target_version}_${migration_id}.migrated"
            if [[ ! -f "$migration_file" ]]; then
                # Run migration
                if "$function_name"; then
                    # Migration succeeded - output is handled by migration function
                    true
                else
                    # Migration failed - log but don't block
                    echo "âš ï¸  Migration failed: $description" >&2
                fi
            fi
        fi
    done
    
    # Remove lock file
    rm -f "$lock_file" 2>/dev/null || true
}

# ============================================================================
# Bug Reporting System
# ============================================================================

# Bug reporting configuration
BUG_REPORT_ENABLED="${BUG_REPORT_ENABLED:-true}"
BUG_REPORT_THRESHOLD="${BUG_REPORT_THRESHOLD:-75}"  # Similarity threshold (%)

# Get GitHub repository URL (sanitized for private repos)
get_bug_report_repo() {
    # Bug reports are always for todo.ai itself, not the repository it's installed in
    # Always return the todo.ai repository URL
    echo "https://github.com/fxstein/todo.ai"
}

# Check if repository is private
is_private_repo() {
    local repo_url="$1"
    if [[ -z "$repo_url" ]]; then
        return 1
    fi
    
    # Check if we can access repository metadata (basic check)
    if command -v gh >/dev/null 2>&1; then
        local repo_info=$(gh repo view "$repo_url" --json isPrivate 2>/dev/null)
        if [[ -n "$repo_info" ]]; then
            local is_private=$(echo "$repo_info" | grep -o '"isPrivate":[^,}]*' | cut -d: -f2)
            if [[ "$is_private" == "true" ]]; then
                return 0
            fi
        fi
    fi
    
    # Default: assume public if we can't determine
    return 1
}

# Collect error context
collect_error_context() {
    local error_message="$1"
    local error_context="$2"
    local command="$3"
    
    # Collect system information
    local os_info=$(uname -srm 2>/dev/null || echo "Unknown")
    local shell_info="$SHELL $(echo $SHELL | xargs -I{} {} --version 2>/dev/null | head -1 || echo '')"
    local version_info="$VERSION"
    
    # Collect recent logs (first 50 log entries from top of file, skipping header lines)
    # NOTE: Log file is sorted in descending order (newest entries at the top)
    # So we use head with grep to skip header lines (# comments) and get the most recent entries
    local recent_logs=""
    if [[ -f "$LOG_FILE" ]]; then
        recent_logs=$(grep -v "^#" "$LOG_FILE" 2>/dev/null | head -n 50 || echo "")
    fi
    
    # Sanitize logs (remove sensitive info)
    recent_logs=$(echo "$recent_logs" | sed 's/password[=:][^[:space:]]*/password=***/gi' || echo "$recent_logs")
    recent_logs=$(echo "$recent_logs" | sed 's/token[=:][^[:space:]]*/token=***/gi' || echo "$recent_logs")
    recent_logs=$(echo "$recent_logs" | sed 's/api[_-]key[=:][^[:space:]]*/api-key=***/gi' || echo "$recent_logs")
    
    # Collect repository info (sanitized for private repos)
    local repo_url=$(get_bug_report_repo)
    local repo_info=""
    if [[ -n "$repo_url" ]] && ! is_private_repo "$repo_url"; then
        repo_info="Git Repository: $repo_url"
    elif [[ -n "$repo_url" ]]; then
        # Private repo - don't include repo identifier
        repo_info="Git Repository: [private repository]"
    fi
    
    # Build context object (we'll use this in generate_bug_report)
    # Use ###FIELD_SEP### as field separator to avoid conflicts with log content which contains pipes
    echo "ERROR_MESSAGE:$error_message###FIELD_SEP###ERROR_CONTEXT:$error_context###FIELD_SEP###COMMAND:$command###FIELD_SEP###OS:$os_info###FIELD_SEP###SHELL:$shell_info###FIELD_SEP###VERSION:$version_info###FIELD_SEP###LOGS:$recent_logs###FIELD_SEP###REPO:$repo_info"
}

# Collect logs for bug report
collect_logs() {
    local max_lines="${1:-50}"
    local log_content=""
    
    # Collect from .todo.ai/.todo.ai.log
    # NOTE: Log file is sorted in descending order (newest entries at the top)
    # So we use head with grep to skip header lines (# comments) and get the most recent entries
    if [[ -f "$LOG_FILE" ]]; then
        log_content=$(grep -v "^#" "$LOG_FILE" 2>/dev/null | head -n "$max_lines" || echo "")
    fi
    
    # Sanitize sensitive information
    log_content=$(echo "$log_content" | sed 's/password[=:][^[:space:]]*/password=***/gi' || echo "$log_content")
    log_content=$(echo "$log_content" | sed 's/token[=:][^[:space:]]*/token=***/gi' || echo "$log_content")
    log_content=$(echo "$log_content" | sed 's/api[_-]key[=:][^[:space:]]*/api-key=***/gi' || echo "$log_content")
    
    echo "$log_content"
}

# Generate bug report template
generate_bug_report() {
    local error_message="$1"
    local error_context="$2"
    local command="${3:-unknown}"
    
    # Collect context
    local context=$(collect_error_context "$error_message" "$error_context" "$command")
    
    # Parse context (using ###FIELD_SEP### as field separator to avoid conflicts with log pipes)
    local os_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^OS:/) {print substr($i, 4); exit}}')
    local shell_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^SHELL:/) {print substr($i, 7); exit}}')
    local version_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^VERSION:/) {print substr($i, 9); exit}}')
    local repo_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^REPO:/) {print substr($i, 6); exit}}')
    
    # Collect logs directly to preserve newlines (don't parse from context string)
    # Use a temporary file to preserve all newlines correctly
    local temp_logs=$(mktemp)
    collect_logs 50 > "$temp_logs"
    local logs=$(cat "$temp_logs")
    rm -f "$temp_logs"
    
    # Format shell version (clean up)
    local shell_version=$(echo "$shell_info" | awk '{print $NF}' | head -1)
    if [[ -z "$shell_version" ]]; then
        shell_version="unknown"
    fi
    
    # Get current date/time
    local current_date=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Get todo.ai path for bug report (use detected path)
    local todo_ai_path=$(get_todo_ai_path_for_rules 2>/dev/null || echo "./todo.ai")
    
    # Build bug report
    local bug_report="## Bug Report

**Version**: $version_info
**Date**: $current_date
**OS**: $os_info
**Shell**: $shell_version

### Error
\`\`\`
$error_message
\`\`\`

### Command
\`\`\`bash
$todo_ai_path $command
\`\`\`

### Error Context
\`\`\`
$error_context
\`\`\`

### Recent Logs
<details>
<summary>Click to expand log history (last 50 lines)</summary>

\`\`\`
$logs
\`\`\`

</details>

### System Information
- OS: $os_info
- Shell: $shell_version
- Script Version: $version_info"
    
    # Only include repo info if not private (or if explicitly requested)
    if [[ -n "$repo_info" ]]; then
        bug_report="$bug_report
- $repo_info"
    fi
    
    bug_report="$bug_report

### Additional Context
[Any additional relevant information]

---
*Reported automatically by todo.ai*"
    
    echo "$bug_report"
}

# Calculate similarity between two strings (simple word-based)
calculate_similarity() {
    local text1="$1"
    local text2="$2"
    
    # Convert to lowercase and extract words
    local words1=$(echo "$text1" | tr '[:upper:]' '[:lower:]' | tr -s '[:space:]' '\n' | sort -u)
    local words2=$(echo "$text2" | tr '[:upper:]' '[:lower:]' | tr -s '[:space:]' '\n' | sort -u)
    
    # Count common words and total unique words
    local common_words=$(comm -12 <(echo "$words1") <(echo "$words2") | wc -l | tr -d ' ')
    local total_unique=$(comm -3 <(echo "$words1") <(echo "$words2") | wc -l | tr -d ' ')
    local total_words=$(comm <(echo "$words1") <(echo "$words2") | wc -l | tr -d ' ')
    
    # Calculate similarity percentage (simple Jaccard-like)
    if [[ $total_unique -eq 0 ]] && [[ $common_words -gt 0 ]]; then
        echo "100"
        return
    fi
    
    # Calculate similarity without bc (fallback for systems without bc)
    if command -v bc >/dev/null 2>&1; then
        local similarity=$(echo "scale=0; $common_words * 100 / ($total_unique + $common_words)" | bc 2>/dev/null || echo "0")
    else
        # Simple integer calculation fallback
        local total=$((total_unique + common_words))
        if [[ $total -gt 0 ]]; then
            local similarity=$((common_words * 100 / total))
        else
            local similarity=0
        fi
    fi
    echo "$similarity"
}

# Check for duplicate issues
check_for_duplicate_issues() {
    local title="$1"
    local body="$2"
    local repo_url="$3"
    
    if [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
                echo ""
        return 1
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        echo ""
        return 1
    fi
    
    # Search for issues with similar titles (extract keywords from title)
    local keywords=$(echo "$title" | tr '[:upper:]' '[:lower:]' | grep -oE '[a-z]+' | head -5 | tr '\n' ' ' | sed 's/ $//')
    
    if [[ -z "$keywords" ]]; then
        echo ""
        return 1
    fi
    
    # Search for issues (limit to last 30 days)
    # Note: Don't include body in initial search as it may contain control characters that break JSON parsing
    local issues_json=$(gh issue list --repo "$repo_url" --search "in:title $keywords" --limit 10 --json number,title,state,createdAt 2>/dev/null || echo "[]")
    
    if [[ -z "$issues_json" ]] || [[ "$issues_json" == "[]" ]]; then
        echo ""
        return 1
    fi
    
    # Parse issues and check similarity
    local duplicates=""
    
    # Use jq if available, otherwise fall back to basic parsing
    if command -v jq >/dev/null 2>&1; then
        # Use jq for proper JSON parsing
        local issues_count=$(echo "$issues_json" | jq '. | length' 2>/dev/null || echo "0")
        
        for ((i=0; i<issues_count; i++)); do
            local issue_number=$(echo "$issues_json" | jq -r ".[$i].number" 2>/dev/null || echo "")
            local issue_title=$(echo "$issues_json" | jq -r ".[$i].title" 2>/dev/null || echo "")
            
            if [[ -z "$issue_number" ]] || [[ -z "$issue_title" ]] || [[ "$issue_number" == "null" ]] || [[ "$issue_title" == "null" ]]; then
                continue
            fi
            
            # Normalize titles for comparison (strip "Bug: " prefix from issue title)
            local normalized_issue_title=$(echo "$issue_title" | sed 's/^Bug: *//')
            local normalized_title="$title"
            
            # Calculate similarity for title
            local title_similarity=$(calculate_similarity "$normalized_title" "$normalized_issue_title")
            
            # Use title similarity (body comparison skipped to avoid JSON parsing issues)
            local max_similarity=$title_similarity
            
            # If similarity >= threshold, consider it a duplicate
            if [[ $max_similarity -ge $BUG_REPORT_THRESHOLD ]]; then
                if [[ -z "$duplicates" ]]; then
                    duplicates="$issue_number|$issue_title|$max_similarity"
                else
                    duplicates="$duplicates\n$issue_number|$issue_title|$max_similarity"
                fi
            fi
        done
    else
        # Fallback to basic parsing (less reliable)
        local issues_count=$(echo "$issues_json" | grep -o '"number"' | wc -l | tr -d ' ')
        
        for ((i=0; i<issues_count; i++)); do
            # Try to extract using awk (more reliable than grep+cut)
            local issue_data=$(echo "$issues_json" | awk -v i="$i" 'BEGIN{RS="},? ?{";FS=","} NR==i+1 {
                for(j=1;j<=NF;j++) {
                    if($j ~ /"number":/) {
                        gsub(/.*"number": ?/, "", $j)
                        gsub(/[^0-9].*/, "", $j)
                        print $j
                        break
                    }
                }
            }' | head -1)
            
            # Simple extraction - this is less reliable but better than before
            local issue_number=$(echo "$issues_json" | awk -v i="$i" '{
                gsub(/.*"number": ?/, "", $0)
                match($0, /[0-9]+/)
                if(RSTART>0) print substr($0, RSTART, RLENGTH)
            }' | sed -n "$((i+1))p")
            
            if [[ -z "$issue_number" ]] || ! [[ "$issue_number" =~ ^[0-9]+$ ]]; then
                continue
            fi
            
            # Extract title (basic approach - get text between "title":" and next "
            local issue_title=$(echo "$issues_json" | grep -o "\"title\":\"[^\"]*\"" | sed -n "$((i+1))p" | sed 's/"title":"//' | sed 's/"$//')
            
            if [[ -z "$issue_title" ]]; then
                continue
            fi
            
            # Normalize titles for comparison (strip "Bug: " prefix from issue title)
            local normalized_issue_title=$(echo "$issue_title" | sed 's/^Bug: *//')
            local normalized_title="$title"
            
            # Calculate similarity for title
            local title_similarity=$(calculate_similarity "$normalized_title" "$normalized_issue_title")
            
            # Use title similarity only (body parsing is too complex without jq)
            local max_similarity=$title_similarity
            
            # If similarity >= threshold, consider it a duplicate
            if [[ $max_similarity -ge $BUG_REPORT_THRESHOLD ]]; then
                if [[ -z "$duplicates" ]]; then
                    duplicates="$issue_number|$issue_title|$max_similarity"
                else
                    duplicates="$duplicates\n$issue_number|$issue_title|$max_similarity"
                fi
            fi
        done
    fi
    
    if [[ -n "$duplicates" ]]; then
        echo -e "$duplicates"
            return 0
        else
        echo ""
            return 1
        fi
}

# Create new GitHub issue
create_new_issue() {
    local title="$1"
    local body="$2"
    local repo_url="$3"
    
    if [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
        echo "Error: GitHub CLI not available or repository not configured"
        return 1
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        echo "Error: GitHub CLI not authenticated. Run 'gh auth login' first"
        return 1
    fi
    
    # Create temporary file for body
    local temp_body=$(mktemp)
    echo "$body" > "$temp_body"
    
    # Create issue (try with auto-reported label, fallback to bug only if label doesn't exist)
    if gh issue create --repo "$repo_url" --title "Bug: $title" --body-file "$temp_body" --label "bug,auto-reported" >/dev/null 2>&1; then
        echo "âœ… Bug report created successfully"
        rm -f "$temp_body"
        return 0
    elif gh issue create --repo "$repo_url" --title "Bug: $title" --body-file "$temp_body" --label "bug" >/dev/null 2>&1; then
        echo "âœ… Bug report created successfully (without auto-reported label)"
        rm -f "$temp_body"
        return 0
    else
        echo "Error: Failed to create issue"
        rm -f "$temp_body"
        return 1
    fi
}

# Reply to existing issue
reply_to_existing_issue() {
    local issue_number="$1"
    local body="$2"
    local repo_url="$3"
    
    if [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
        echo "Error: GitHub CLI not available or repository not configured"
        return 1
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        echo "Error: GitHub CLI not authenticated. Run 'gh auth login' first"
        return 1
    fi
    
    # Create "me too" message
    local me_too_message="## Me Too - Same Issue Encountered

**Version**: $VERSION
**Date**: $(date '+%Y-%m-%d %H:%M:%S')
**OS**: $(uname -srm 2>/dev/null || echo 'Unknown')

I'm experiencing the same error. Here's my context:

$body

---
*Reported automatically by todo.ai*"
    
    # Create temporary file for comment
    local temp_comment=$(mktemp)
    echo "$me_too_message" > "$temp_comment"
    
    # Add comment to issue
    if gh issue comment "$issue_number" --repo "$repo_url" --body-file "$temp_comment" >/dev/null 2>&1; then
        echo "âœ… Added 'me too' comment to issue #$issue_number"
        rm -f "$temp_comment"
        return 0
    else
        echo "Error: Failed to add comment to issue"
        rm -f "$temp_comment"
        return 1
    fi
}

# Handle duplicate detection with user confirmation
handle_duplicate_detection() {
    local title="$1"
    local body="$2"
    local repo_url="$3"
    
    # Check for duplicates
    local duplicates=$(check_for_duplicate_issues "$title" "$body" "$repo_url")
    
    if [[ -n "$duplicates" ]]; then
        echo ""
        echo "Similar issues found:"
        echo ""
        
        # Display duplicates and collect issue numbers
        local count=1
        local issue_numbers=()
        while IFS='|' read -r issue_num issue_title similarity; do
            if [[ -n "$issue_num" ]]; then
                echo "$count) Issue #$issue_num: $issue_title (similarity: ${similarity}%)"
                issue_numbers+=("$issue_num")
                count=$((count + 1))
            fi
        done <<< "$duplicates"
        
        echo ""
        printf "Would you like to add a 'me too' comment to an existing issue? (y/N) "
        read -r reply
        
        if [[ "$reply" =~ ^[Yy]$ ]]; then
            # Ask which issue
            echo ""
            printf "Enter issue number to reply to: "
            read -r selected_num
            
            if [[ -n "$selected_num" ]] && [[ "$selected_num" =~ ^[0-9]+$ ]]; then
                if reply_to_existing_issue "$selected_num" "$body" "$repo_url"; then
                    return 0
                else
                    echo "Error: Failed to add comment. Bug report cancelled."
                    return 1
                fi
            else
                echo "Invalid issue number"
                return 1
            fi
        else
            printf "Create a new issue instead? (y/N) "
            read -r reply
            if [[ "$reply" =~ ^[Yy]$ ]]; then
                create_new_issue "$title" "$body" "$repo_url"
            else
                echo "Bug report cancelled"
                return 0
            fi
        fi
    else
        # No duplicates, ask to create new issue
        printf "Would you like to create a new issue? (y/N) "
        read -r reply
        if [[ "$reply" =~ ^[Yy]$ ]]; then
            create_new_issue "$title" "$body" "$repo_url"
        else
            echo "Bug report cancelled"
            return 0
        fi
    fi
}

# Main bug reporting entry point - ALWAYS requires user confirmation
suggest_bug_report() {
    local error_message="$1"
    local error_context="$2"
    local command="${3:-unknown}"
    
    # Check if bug reporting is enabled
    if [[ "$BUG_REPORT_ENABLED" != "true" ]]; then
        return 0
    fi
    
    # Get repository URL
    local repo_url=$(get_bug_report_repo)
    if [[ -z "$repo_url" ]]; then
        echo "âš ï¸  Cannot report bug: No GitHub repository configured"
        return 1
    fi
    
    # Generate bug report
    local bug_report=$(generate_bug_report "$error_message" "$error_context" "$command")
    
    # Extract title from error message (first line, max 100 chars)
    local title=$(echo "$error_message" | head -1 | cut -c1-100)
    
    # Show error and suggestion
    echo ""
    echo "âš ï¸  An error occurred: $error_message"
    echo ""
    echo "Would you like to report this bug to GitHub Issues?"
    echo ""
    echo "Preview of bug report:"
    echo "---"
    # Show header up to (but not including) Recent Logs section
    echo "$bug_report" | sed -n '1,/^### Recent Logs$/p' | sed '$d'
    # Show Recent Logs section header
    echo "### Recent Logs"
    echo "<details>"
    echo "<summary>Click to expand log history (last 50 lines)</summary>"
    echo ""
    echo "\`\`\`"
    # Extract and show first 5 log entries
    local first_logs=$(echo "$bug_report" | sed -n '/```/,/```/p' | grep "^2025-" | head -5)
    echo "$first_logs"
    # Count total log entries
    local log_count=$(echo "$bug_report" | sed -n '/```/,/```/p' | grep -c "^2025-" || echo "0")
    if [[ $log_count -gt 5 ]]; then
        echo "... (showing 5 of $log_count log entries; all $log_count entries will be included in full report) ..."
    fi
    echo "\`\`\`"
    echo ""
    echo "</details>"
    # Show footer (System Information onwards)
    echo "$bug_report" | sed -n '/^### System Information/,/---/p'
    echo "---"
    echo ""
    
    # Always require confirmation
    printf "Report this bug? (y/N) "
    read -r reply
    
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        echo "Bug report cancelled by user"
        return 0
    fi
    
    # User confirmed - proceed with duplicate check and reporting
    handle_duplicate_detection "$title" "$bug_report" "$repo_url"
}

# Command handler for manual bug reporting
report_bug() {
    local error_description="$1"
    local error_context="${2:-}"
    local command="${3:-}"
    
    if [[ -z "$error_description" ]]; then
        local todo_ai_path=$(get_todo_ai_path_for_rules 2>/dev/null || echo "./todo.ai")
        echo "Error: Please provide an error description"
        echo "Usage: $todo_ai_path report-bug \"Error description\" [error context] [command]"
        return 1
    fi
    
    suggest_bug_report "$error_description" "$error_context" "$command"
}

# Function to uninstall todo.ai
uninstall_tool() {
    local remove_data=false
    local remove_rules=false
    local force=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --remove-data|--data)
                remove_data=true
                shift
                ;;
            --remove-rules|--rules)
                remove_rules=true
                shift
                ;;
            --all)
                remove_data=true
                remove_rules=true
                shift
                ;;
            --force|-f)
                force=true
                shift
                ;;
            *)
                echo "Error: Unknown option '$1'"
                echo "Usage: ./todo.ai uninstall [--remove-data] [--remove-rules] [--all] [--force]"
                return 1
                ;;
        esac
    done
    
    # Get script path
    local script_path
    script_path=$(get_script_path) || {
        echo "âš ï¸  Cannot locate todo.ai script"
        echo "   It may already be uninstalled."
        return 1
    }
    
    # Detect .todo.ai/ directory (in current working directory)
    local todo_ai_dir="$(pwd)/.todo.ai"
    local has_data_dir=false
    if [[ -d "$todo_ai_dir" ]]; then
        has_data_dir=true
    fi
    
    # Detect Cursor rules created by todo.ai
    local rules_dir="$(pwd)/.cursor/rules"
    local todo_ai_rules=()
    if [[ -d "$rules_dir" ]]; then
        # Find all todo.ai-*.mdc files
        for rule_file in "$rules_dir"/todo.ai-*.mdc; do
            if [[ -f "$rule_file" ]]; then
                todo_ai_rules+=("$rule_file")
            fi
        done
    fi
    
    # Build what will be removed list
    echo ""
    echo "ðŸ—‘ï¸  Uninstalling todo.ai"
    echo ""
    echo "The following will be removed:"
    
    local will_remove_script=true
    local will_remove_data=false
    local will_remove_rules=false
    
    if [[ -f "$script_path" ]]; then
        echo "  âœ— Script: $script_path"
    else
        will_remove_script=false
    fi
    
    if [[ "$remove_data" == true ]] && [[ "$has_data_dir" == true ]]; then
        echo "  âœ— Data directory: $todo_ai_dir"
        will_remove_data=true
        echo "     âš ï¸  Warning: This will remove your TODO data (.todo.ai/ directory)"
        echo "     âš ï¸  Your TODO.md file will remain untouched"
    elif [[ "$has_data_dir" == true ]]; then
        echo "  âœ“ Data directory: $todo_ai_dir (preserved - use --remove-data to remove)"
    fi
    
    if [[ "$remove_rules" == true ]] && [[ ${#todo_ai_rules[@]} -gt 0 ]]; then
        echo "  âœ— Cursor rules:"
        for rule_file in "${todo_ai_rules[@]}"; do
            echo "      - $(basename "$rule_file")"
        done
        will_remove_rules=true
    elif [[ ${#todo_ai_rules[@]} -gt 0 ]]; then
        echo "  âœ“ Cursor rules: ${#todo_ai_rules[@]} file(s) (preserved - use --remove-rules to remove)"
    fi
    
    # Safety check: ensure we have something to remove
    if [[ "$will_remove_script" == false ]] && [[ "$will_remove_data" == false ]] && [[ "$will_remove_rules" == false ]]; then
        echo ""
        echo "âœ… Nothing to remove. Script not found or already uninstalled."
        return 0
    fi
    
    echo ""
    
    # Confirmation (unless --force)
    if [[ "$force" != true ]]; then
        printf "Proceed with uninstall? (y/N) "
        read -r reply
        if [[ ! "$reply" =~ ^[Yy]$ ]]; then
            echo "Uninstall cancelled"
            return 0
        fi
    fi
    
    # Remove script
    if [[ "$will_remove_script" == true ]]; then
        if rm -f "$script_path" 2>/dev/null; then
            echo "âœ… Removed script: $script_path"
        else
            echo "âš ï¸  Error: Could not remove script: $script_path"
            echo "   You may need to remove it manually"
            return 1
        fi
    fi
    
    # Remove data directory
    if [[ "$will_remove_data" == true ]]; then
        if rm -rf "$todo_ai_dir" 2>/dev/null; then
            echo "âœ… Removed data directory: $todo_ai_dir"
        else
            echo "âš ï¸  Error: Could not remove data directory: $todo_ai_dir"
            echo "   You may need to remove it manually"
        fi
    fi
    
    # Remove Cursor rules
    if [[ "$will_remove_rules" == true ]]; then
        local rules_removed=0
        for rule_file in "${todo_ai_rules[@]}"; do
            if rm -f "$rule_file" 2>/dev/null; then
                rules_removed=$((rules_removed + 1))
            fi
        done
        if [[ $rules_removed -gt 0 ]]; then
            echo "âœ… Removed $rules_removed Cursor rule(s)"
        else
            echo "âš ï¸  Error: Could not remove Cursor rules"
            echo "   You may need to remove them manually from $rules_dir"
        fi
    fi
    
    echo ""
    echo "âœ… Uninstall complete!"
    
    return 0
}

# Migration: Fix section order in TODO.md
migrate_section_order() {
    local migration_id="section_order_fix"
    local migrations_dir="$(pwd)/.todo.ai/migrations"
    local migration_file="${migrations_dir}/v1.3.5_${migration_id}.migrated"
    
    # Check if already migrated
    if [[ -f "$migration_file" ]]; then
        return 0
    fi
    
    # Check prerequisites
    if [[ ! -f "$TODO_FILE" ]]; then
        return 1
    fi
    
    # Check if sections are in wrong order (Deleted Tasks before Recently Completed)
    local deleted_line=$(grep -n "^## Deleted Tasks" "$TODO_FILE" | cut -d: -f1 | head -1)
    local recently_completed_line=$(grep -n "^## Recently Completed" "$TODO_FILE" | cut -d: -f1 | head -1)
    
    # If both exist and Deleted is before Recently Completed, fix it
    if [[ -n "$deleted_line" ]] && [[ -n "$recently_completed_line" ]] && [[ $deleted_line -lt $recently_completed_line ]]; then
        # Extract sections
        local temp_file=$(mktemp)
        
        # Find where Recently Completed section ends (next section header or end of file)
        local next_section_line=$(awk "NR > $recently_completed_line && /^## / {print NR; exit}" "$TODO_FILE" || echo "")
        local recently_completed_end
        if [[ -z "$next_section_line" ]]; then
            # No next section, Recently Completed is at end of file
            recently_completed_end=$(wc -l < "$TODO_FILE" | tr -d ' ')
        else
            recently_completed_end=$((next_section_line - 1))
        fi
        
        # Find where Deleted Tasks section ends
        local deleted_end
        if [[ -z "$next_section_line" ]]; then
            # If Deleted was the last section before Recently Completed
            deleted_end=$((recently_completed_line - 1))
        else
            # Find next section after Deleted
            local deleted_next_section=$(awk "NR > $deleted_line && /^## / {print NR; exit}" "$TODO_FILE" || echo "")
            if [[ -n "$deleted_next_section" ]]; then
                deleted_end=$((deleted_next_section - 1))
            else
                deleted_end=$(wc -l < "$TODO_FILE" | tr -d ' ')
            fi
        fi
        
        # Extract Deleted Tasks section (including header)
        local deleted_section=$(sed -n "${deleted_line},${deleted_end}p" "$TODO_FILE")
        
        # Remove Deleted Tasks section from original file
        sed_inplace "${deleted_line},${deleted_end}d" "$TODO_FILE"
        
        # Recalculate line numbers after deletion
        recently_completed_line=$(grep -n "^## Recently Completed" "$TODO_FILE" | cut -d: -f1 | head -1)
        if [[ -n "$recently_completed_line" ]]; then
            # Find where Recently Completed section ends now
            local new_next_section=$(awk "NR > $recently_completed_line && /^## / {print NR; exit}" "$TODO_FILE" || echo "")
            local insert_line
            if [[ -z "$new_next_section" ]]; then
                # No next section, insert at end
                insert_line=$(wc -l < "$TODO_FILE" | tr -d ' ')
            else
                # Insert before next section
                insert_line=$((new_next_section - 1))
            fi
            
            # Insert Deleted Tasks section after Recently Completed
            if [[ "$(uname)" == "Darwin" ]]; then
                # macOS approach: use temporary file
                head -n "$insert_line" "$TODO_FILE" > "$temp_file"
                echo "" >> "$temp_file"
                echo "$deleted_section" >> "$temp_file"
                tail -n +$((insert_line + 1)) "$TODO_FILE" >> "$temp_file" 2>/dev/null || true
                mv "$temp_file" "$TODO_FILE"
            else
                # Linux approach: use sed
                echo "$deleted_section" > "$temp_file"
                sed_inplace "${insert_line}r $temp_file" "$TODO_FILE"
                rm -f "$temp_file"
            fi
            
            echo "âœ“ Migration: Fixed TODO.md section order" >&2
        fi
    fi
    
    # Mark as complete
    mkdir -p "$migrations_dir" 2>/dev/null || return 1
    touch "$migration_file" 2>/dev/null || return 1
    
    return 0
}

# Migration: Convert .cursorrules to .cursor/rules/ directory structure
migrate_cursor_rules_to_mdc() {
    local migration_id="cursor_rules_to_mdc"
    local migrations_dir="$(pwd)/.todo.ai/migrations"
    local migration_file="${migrations_dir}/v1.6.0_${migration_id}.migrated"
    
    # Check if already migrated
    if [[ -f "$migration_file" ]]; then
        return 0
    fi
    
    # Check prerequisites: .cursorrules must exist
    local cursorrules_file="$(pwd)/.cursorrules"
    if [[ ! -f "$cursorrules_file" ]]; then
        # No .cursorrules file, nothing to migrate
        return 0
    fi
    
    # Create .cursor/rules/ directory
    local rules_dir="$(pwd)/.cursor/rules"
    mkdir -p "$rules_dir" 2>/dev/null || return 1
    
    # Mapping of section names to .mdc filenames
    # Format: "Section Name|filename|description|is_end_user_rule"
    declare -a section_mappings=(
        "Task Management|todo.ai-task-management|Task management rules for todo.ai|true"
        "Installation|todo.ai-installation|Installation instructions for todo.ai|true"
        "Bug Reporting|todo.ai-bug-reporting|Bug reporting rules for todo.ai|true"
        "Uninstall|todo.ai-uninstall|Uninstall rules for todo.ai|true"
        "Releases|releases|Release process for todo.ai development|false"
        "Commit Message Prefixes for Release Numbering|commit-prefixes|Commit message prefix guidelines for release numbering|false"
    )
    
    # Extract all sections from .cursorrules
    local section_count=0
    local current_section=""
    local current_section_content=""
    local temp_content=$(mktemp)
    
    # Parse .cursorrules file section by section
    while IFS= read -r line; do
        # Check if this is a section header
        if [[ "$line" =~ ^##[[:space:]] ]]; then
            # Save previous section if exists
            if [[ -n "$current_section" ]] && [[ -n "$current_section_content" ]]; then
                # Find mapping for this section
                local section_found=false
                for mapping in "${section_mappings[@]}"; do
                    IFS='|' read -r section_name filename description is_end_user <<< "$mapping"
                    if [[ "$current_section" == "$section_name" ]]; then
                        section_found=true
                        
                        # Create .mdc file with YAML front matter
                        local mdc_file="${rules_dir}/${filename}.mdc"
                        
                        # Write YAML front matter
                        cat > "$mdc_file" << EOF
---
description: "$description"
alwaysApply: true
---
EOF
                        # Write section content (strip the ## header, keep rest)
                        echo "$current_section_content" | sed '1d' | sed 's/^[[:space:]]*$//' >> "$mdc_file"
                        
                        section_count=$((section_count + 1))
                        break
                    fi
                done
                
                # If section not found in mapping, skip it (user custom content)
                if [[ "$section_found" == false ]]; then
                    echo "âš ï¸  Skipping unmapped section: $current_section" >&2
                fi
            fi
            
            # Start new section (extract section name using sed)
            current_section=$(echo "$line" | sed 's/^##[[:space:]]*//')
            current_section_content="$line"
        else
            # Add line to current section content
            if [[ -n "$current_section" ]]; then
                current_section_content="$current_section_content
$line"
            fi
        fi
    done < "$cursorrules_file"
    
    # Don't forget the last section
    if [[ -n "$current_section" ]] && [[ -n "$current_section_content" ]]; then
        local section_found=false
        for mapping in "${section_mappings[@]}"; do
            IFS='|' read -r section_name filename description is_end_user <<< "$mapping"
            if [[ "$current_section" == "$section_name" ]]; then
                section_found=true
                
                local mdc_file="${rules_dir}/${filename}.mdc"
                
                cat > "$mdc_file" << EOF
---
description: "$description"
alwaysApply: true
---
EOF
                echo "$current_section_content" | sed '1d' | sed 's/^[[:space:]]*$//' >> "$mdc_file"
                
                section_count=$((section_count + 1))
                break
            fi
        done
        
        if [[ "$section_found" == false ]]; then
            echo "âš ï¸  Skipping unmapped section: $current_section" >&2
        fi
    fi
    
    rm -f "$temp_content"
    
    if [[ $section_count -gt 0 ]]; then
        echo "âœ“ Migration: Converted $section_count section(s) from .cursorrules to .cursor/rules/" >&2
        echo "   ðŸ“ Migrated to .cursor/rules/ directory structure" >&2
        echo "   ðŸ”„ ACTION REQUIRED: Cursor rules migrated to new format!" >&2
        echo "" >&2
        echo "   For Humans:" >&2
        echo "   â†’ Please start a new chat session in Cursor" >&2
        echo "   â†’ The old .cursorrules file can be removed if migration succeeded" >&2
        echo "" >&2
        echo "   For AI Agents:" >&2
        echo "   â†’ Inform the user that cursor rules have been migrated" >&2
        echo "   â†’ Request that the user start a new chat session" >&2
        
        # Cleanup: Remove todo.ai references from .cursorrules after successful migration
        # Create timestamped backup before making any edits
        local timestamp=$(date +"%Y%m%d%H%M%S")
        local backup_file="${cursorrules_file}.backup.${timestamp}"
        
        if cp "$cursorrules_file" "$backup_file" 2>/dev/null; then
            echo "   ðŸ’¾ Created backup: $(basename "$backup_file")" >&2
            
            # Create temporary file for cleaned content
            local cleaned_file=$(mktemp)
            local in_todo_ai_section=false
            local current_section_name=""
            
            # Parse .cursorrules and remove todo.ai-specific sections and paragraphs
            local paragraph_buffer=""
            local in_paragraph=false
            
            while IFS= read -r line || [[ -n "$line" ]]; do
                # Check if this is a section header
                if [[ "$line" =~ ^##[[:space:]] ]]; then
                    # Save previous section if we were in one
                    if [[ "$in_todo_ai_section" == true ]]; then
                        # Skip this section - don't write it
                        in_todo_ai_section=false
                    fi
                    
                    # Write accumulated paragraph buffer if it's not todo.ai-specific
                    if [[ -n "$paragraph_buffer" ]] && [[ "$in_paragraph" == true ]]; then
                        # Check if paragraph references todo.ai
                        local paragraph_lower=$(echo "$paragraph_buffer" | tr '[:upper:]' '[:lower:]')
                        if [[ ! "$paragraph_lower" =~ (todo\.ai|todo-ai) ]]; then
                            echo "$paragraph_buffer" >> "$cleaned_file"
                        fi
                        paragraph_buffer=""
                        in_paragraph=false
                    fi
                    
                    # Extract section name
                    current_section_name=$(echo "$line" | sed 's/^##[[:space:]]*//')
                    
                    # Check if this section is in our mapping (todo.ai-specific)
                    in_todo_ai_section=false
                    for mapping in "${section_mappings[@]}"; do
                        IFS='|' read -r section_name filename description is_end_user <<< "$mapping"
                        if [[ "$current_section_name" == "$section_name" ]]; then
                            in_todo_ai_section=true
                            break
                        fi
                    done
                    
                    # Write section header only if not todo.ai-specific
                    if [[ "$in_todo_ai_section" == false ]]; then
                        echo "$line" >> "$cleaned_file"
                    fi
                elif [[ -z "$line" ]] || [[ "$line" =~ ^[[:space:]]*$ ]]; then
                    # Empty line - end of paragraph
                    if [[ -n "$paragraph_buffer" ]] && [[ "$in_paragraph" == true ]]; then
                        # Check if paragraph references todo.ai
                        local paragraph_lower=$(echo "$paragraph_buffer" | tr '[:upper:]' '[:lower:]')
                        if [[ ! "$paragraph_lower" =~ (todo\.ai|todo-ai) ]]; then
                            echo "$paragraph_buffer" >> "$cleaned_file"
                        fi
                        paragraph_buffer=""
                        in_paragraph=false
                    fi
                    # Write empty line only if not in todo.ai section
                    if [[ "$in_todo_ai_section" == false ]]; then
                        echo "$line" >> "$cleaned_file"
                    fi
                else
                    # Regular line - check if it's part of a paragraph
                    if [[ "$in_todo_ai_section" == false ]]; then
                        # Check if line references todo.ai directly
                        local line_lower=$(echo "$line" | tr '[:upper:]' '[:lower:]')
                        if [[ "$line_lower" =~ (todo\.ai|todo-ai) ]]; then
                            # Skip this line - it references todo.ai
                            continue
                        fi
                        
                        # Add to paragraph buffer or write directly
                        if [[ "$line" =~ ^[[:space:]]*- ]] || [[ "$line" =~ ^[[:space:]]*\* ]] || [[ "$line" =~ ^[[:space:]]*[0-9]+\. ]]; then
                            # List item - write directly (not part of a paragraph)
                            echo "$line" >> "$cleaned_file"
                        else
                            # Regular text - accumulate in paragraph buffer
                            if [[ -z "$paragraph_buffer" ]]; then
                                paragraph_buffer="$line"
                            else
                                paragraph_buffer="${paragraph_buffer}
${line}"
                            fi
                            in_paragraph=true
                        fi
                    fi
                fi
            done < "$cursorrules_file"
            
            # Write any remaining paragraph buffer
            if [[ -n "$paragraph_buffer" ]] && [[ "$in_paragraph" == true ]]; then
                local paragraph_lower=$(echo "$paragraph_buffer" | tr '[:upper:]' '[:lower:]')
                if [[ ! "$paragraph_lower" =~ (todo\.ai|todo-ai) ]]; then
                    echo "$paragraph_buffer" >> "$cleaned_file"
                fi
            fi
            
            # Check if cleaned file has any content (not just whitespace)
            local has_content=false
            if [[ -s "$cleaned_file" ]] && grep -q "[^[:space:]]" "$cleaned_file" 2>/dev/null; then
                has_content=true
            fi
            
            if [[ "$has_content" == true ]]; then
                # Replace original file with cleaned content
                mv "$cleaned_file" "$cursorrules_file" 2>/dev/null || {
                    echo "âš ï¸  Warning: Could not update .cursorrules file" >&2
                    rm -f "$cleaned_file"
                    return 1
                }
                echo "   ðŸ§¹ Cleaned .cursorrules: Removed todo.ai-specific sections" >&2
                echo "   ðŸ’¾ Backup saved as: $(basename "$backup_file")" >&2
            else
                # File is empty after cleanup - remove it entirely
                rm -f "$cleaned_file"
                rm -f "$cursorrules_file"
                echo "   ðŸ—‘ï¸  Removed .cursorrules: No remaining content after removing todo.ai sections" >&2
                echo "   ðŸ’¾ Backup saved as: $(basename "$backup_file")" >&2
            fi
        else
            echo "âš ï¸  Warning: Could not create backup of .cursorrules" >&2
            # Still proceed with migration, but skip cleanup
        fi
    fi
    
    # Mark as complete
    mkdir -p "$migrations_dir" 2>/dev/null || return 1
    touch "$migration_file" 2>/dev/null || return 1
    
    return 0
}

# Initialize log file
init_log_file

# Initialize TODO file
init_todo_file

# Run migrations (after initialization, before main logic)
run_migrations

# Initialize Cursor rules if needed (check on every run, add if missing)
init_cursor_rules

# Main script logic
case "${1:-}" in
    "add")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "add" "$@"; then
            exit 1
        fi
        add_todo "$1" "$2"
        ;;
    "add-subtask")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "add-subtask" "$@"; then
            exit 1
        fi
        add_subtask "$1" "$2" "$3"
        ;;
    "list")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "list" "$@"; then
            exit 1
        fi
        list_todos "$@"
        ;;
    "complete")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "complete" "$@"; then
            exit 1
        fi
        complete_todo "$@"
        ;;
    "undo")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "undo" "$@"; then
            exit 1
        fi
        undo_todo "$1"
        ;;
    "modify")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "modify" "$@"; then
            exit 1
        fi
        modify_todo "$1" "$2" "$3"
        ;;
    "archive")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "archive" "$@"; then
            exit 1
        fi
        # Parse task IDs and reason flag
        local task_ids=()
        local reason_arg=""
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --reason)
                    reason_arg="--reason"
                    reason_value="$2"
                    shift 2
                    ;;
                *)
                    task_ids+=("$1")
                    shift
                    ;;
            esac
        done
        # Archive each task with reason if provided
        for task_id in "${task_ids[@]}"; do
            if [[ -n "$reason_arg" ]]; then
                archive_task "$task_id" --reason "$reason_value"
            else
                archive_task "$task_id"
            fi
        done
        ;;
    "delete")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "delete" "$@"; then
            exit 1
        fi
        delete_task "$@"
        ;;
    "relate")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "relate" "$@"; then
            exit 1
        fi
        relate_task "$@"
        ;;
    "note")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "note" "$@"; then
            exit 1
        fi
        add_note "$1" "$2"
        ;;
    "show")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "show" "$@"; then
            exit 1
        fi
        show_task "$1"
        ;;
    "restore")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "restore" "$@"; then
            exit 1
        fi
        restore_task "$1"
        ;;
    "--lint")
        lint_todo
        ;;
    "--reformat")
        if [[ "$2" == "--dry-run" ]]; then
            reformat_todo "--dry-run"
        else
            reformat_todo
        fi
        ;;
    "resolve-conflicts")
        shift
        if [[ "$1" == "--dry-run" ]]; then
            resolve_conflicts "--dry-run"
        else
            resolve_conflicts
        fi
        ;;
    "edit")
        edit_todo
        ;;
    "log")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "log" "$@"; then
            exit 1
        fi
        if [[ "$1" == "--filter" && -n "$2" ]]; then
            view_log "$2" "$3"
        elif [[ "$1" == "--lines" && -n "$2" ]]; then
            view_log "" "$2"
        else
            view_log
        fi
        ;;
    "update")
        update_tool
        ;;
    "backups"|"list-backups")
        list_backups
        ;;
    "rollback")
        shift
        rollback "$@"
        ;;
    "report-bug")
        shift
        report_bug "$1" "$2" "$3"
        ;;
    "uninstall")
        shift
        uninstall_tool "$@"
        ;;
    "switch-mode")
        shift
        switch_mode "$@"
        ;;
    "list-mode-backups")
        list_mode_backups
        ;;
    "rollback-mode")
        shift
        rollback_from_backup "$1"
        ;;
    "version"|"--version"|"-v")
        echo "todo.ai version $VERSION"
        echo "Repository: $REPO_URL"
        echo "Update: ./todo.ai update"
        ;;
    "--help"|"help"|"-h")
        show_usage
        ;;
    *)
        show_usage
        ;;
esac